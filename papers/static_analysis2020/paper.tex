\documentclass[english,runningheads]{llncs}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{babel}
\usepackage{multirow}
\usepackage[bottom]{footmisc}
\usepackage[table,xcdraw]{xcolor}

\DeclareUnicodeCharacter{00D7}{$\times$}

\begin{document}
\title{Efficient static analysis of Marlowe contracts}

\author{Pablo {Lamela Seijas}\inst{1}\orcidID{0000-0002-1730-1219} \and
        David Smith\inst{1}\orcidID{0000-0003-1859-8007} \and
        Simon Thompson\inst{1,2}\orcidID{0000-0002-2350-301X}}

\authorrunning{P. Lamela Seijas, et al.}

\institute{IOHK, Hong Kong,
\email{pablo.lamela@iohk.io, david.smith@tweag.io, simon.thompson@iohk.io}  \and
School of Computing, University of Kent, UK,
\email{s.j.thompson@kent.ac.uk}}

\maketitle
\begin{abstract}
SMT solvers can verify properties automatically and efficiently, and they offer increasing
flexibility on the ways those properties can be described. But it is hard to predict how those ways of describing the properties affect the computational cost of verifying them.

In this paper, we discuss what we learned while implementing and optimising the static analysis for Marlowe, a domain specific language for self-enforcing financial smart-contracts that can be deployed on a blockchain.
\end{abstract}
\section{Introduction\label{sec:Introduction}}

Thanks to static analysis, we can automatically check beforehand whether any
payments promised by a Marlowe~\cite{marlowe2020,Marlowe:2018} contract can be fulfilled in every
possible execution of the contract. If a Marlowe contract has passed
the static analysis, we will have a very high assurance
that whenever the contract says it will make a payment, the contract will
indeed have enough money available.

Marlowe's static analysis relies on SMT solvers, which are able to check efficiently
whether a set of constraints is satisfiable. The main property for us is whether a contract will have enough money for all payments to be made in full.

Thanks to state of the art
libraries like SBV \cite{erkok2019sbv}, we can describe those constraints in a
high level language. In the case of SBV, we can write properties as
Haskell functions, with few restrictions on how those functions are
implemented; SBV automatically translates those functions to SMTLib format \cite{barrett2010smt}, a language many SMT solvers understand.
However, high level abstractions often have a tradeoff with efficiency, and static analysis can become very expensive computationally if
implemented naïvely, because it is NP-complete in the general case.
 

% Indeed, high level abstractions are often a tradeoff with efficiency.

% For example, in the case of Marlowe, contracts are typically interactive
% and must deal with inputs arriving from different users in different
% orders, and sometimes not arriving at all. In addition, Marlowe allows
% several inputs to be grouped in a single transaction, and different
% decisions may be taken depending on the content of those inputs, or
% in the combinations of contents of those inputs. All these alternatives
% multiply the search space of static analysis and can easily compose
% exponentially and thus make the whole approach unusable in practice
% even for moderately sized contracts.

This paper contributes a number of approaches that can be used when
optimising static analysis, with examples extracted from a case-study where
we applied these approaches. Our approach aims to ensure correctness
of the optimisations by combining the use of property-based testing
and with verification in an automated theorem prover to establish properties of the optimisations. We also present empirical data
that measures the effect of some of the optimisations on the implementation
of our Marlowe case-study.

The techniques described helped us reduce the analysis time of an implementation
that followed the semantics closely and took a couple of minutes to analyse contracts
of a few kilobytes, to one where the same contract takes less
than a second to analyse, and where a four-person crowdfunding contract that
fully expanded occupies about 19 megabytes, can be analysed in
around 10 minutes. 
We have classified optimisation techniques as lightweight and heavyweight. 

\paragraph*{Lightweight}

modifications are local and can be done without fundamentally changing
the implementation. We consider three main ideas:
\begin{itemize}
\item \textbf{Removing unnecessary parts from the analysis}. If they do not affect
the property that is being verified then we can just remove them.
\item \textbf{Avoiding high level abstractions}. High level abstractions aid reasoning
and avoid errors, but also introduce complexity that may not be necessary.
\item \textbf{Reducing the search space by normalising parameters}. If there are several
ways of representing some inputs, and the different representations
have no impact on the analysis, we can remove all but one for analysis.
\end{itemize}

\paragraph*{Heavyweight}

modifications are more fundamental approaches that require considerable
changes to the structure of the implementation. But these optimisations can also
translate in important reductions to execution time and memory usage, as
shown by the experiments we report in Section~\ref{sec:Measurements}.
We consider two main ideas:
\begin{itemize}
\item \textbf{Reducing the search space by using normalised execution paths relevant
to the property}. Instead of using the search space to model inputs, we
use it to model possible executions, and we only
represent each equivalence class of executions once, i.e:
we represent them in a normal form.
\item \textbf{Minimizing the representation of inputs and outputs}. We encode inputs
and outputs as concisely as possible, discarding inferable information.
\end{itemize}
In the following sections, we introduce the semantics of Marlowe as
a case study (Section~\ref{sec:Marlowe-intro}), and we cover a
general approach to static analysis (Section~\ref{sec:Making-Marlowe-symbolic}).
We then, in Section \ref{sec:Making-static-analysis-efficient} explore in Section the lightweight and heavyweight 
optimisation techniques in more detail, and illustrate them with
examples of how they apply to Marlowe static analysis. In Section~\ref{sec:Testing},
we illustrate the use of property based testing on the implementation with
heavyweight optimisations. Finally, we present empirical results that
show the effect of heavyweight optimisations on the execution time
and memory usage of Marlowe's static analysis (Section~\ref{sec:Measurements}).

\section{Marlowe design and semantics\label{sec:Marlowe-intro} }

Firstly, we introduce the semantics of Marlowe, the guarantees
that are offered implicitly by the semantics, and how the design choices
facilitate static analysis and make it decidable. A more detailed
explanation can be found in \cite{marlowe2020}.

\subsection{Structure of Marlowe contracts\label{subsec:Structure-of-Marlowe} }

The Marlowe language is realised as a set of mutually recursive Haskell
data types. Marlowe contracts regulate interactions between a finite number
of participants, determined before the contract is deployed.

Marlowe contracts are able to receive payments, store money and tokens,
ask for input from its participants, and redistribute stored money
and tokens among participants. A contract determines when and which of
these actions may be carried out. Participants may correspond to either
individual public keys or to tokens (\texttt{Role}s). In turn, \texttt{Role}s
may be controlled by other contracts.

The main data type in Marlowe is called \texttt{Contract}, and it represents
the logic and actions that the contract allows or enforces. The outmost
constructs of the \texttt{Contract} represent the actions that will be enforced
first and, as those constructs become enforced, the \texttt{Contract} will
evolve into one of its continuations (sub-contracts), and the process
will continue until only the construct \texttt{Close} remains.

There are 5 constructs of type \texttt{Contract}:
\begin{itemize}
\item \texttt{Close} -- signals the end of the life of a contract. Once
it is reached, all the money and tokens stored in the accounts of
the contract will be refunded to the owner of each of the respective
accounts.
\item \texttt{If} -- immediately decides how the contract must continue
from between two possibilities, depending on a given Boolean condition
that we call an \texttt{Observation}. An \texttt{Observation}
may depend on previous choices by participants, on amounts of money
and tokens in the contract, or other factors.
\item \texttt{Let} -- immediately stores a \texttt{Value} for later use.
Expressions of type \texttt{Value} in Marlowe are evaluated to integer
values and they depend on information available to the contract at the
time of evaluation. For example, a \texttt{Let} construct record
the amount of money in an account at a point in time.
\item \texttt{When} -- waits for an external input. The \texttt{When} construct
also specifies a timeout slot\footnote{Slots are blockchain's proxy for time,
they are added to the blockchain periodically.}: after this slot has been reached, the
\texttt{When} construct expires, and no longer accepts any input.
There are three kinds of input:
\begin{itemize}
\item \texttt{Deposit} -- Waits for a participant to deposit an amount
of money or tokens (specified as a \texttt{Value}) in an account of the contract.
\item \texttt{Choice} -- Waits for a participant to make a choice. A choice
is represented as an integer number from a set specified by the contract.
\item \texttt{Notify} -- Waits for an \texttt{Observation} to be true.
Because contracts are reactive (they cannot initiate transactions),
it is necessary for an external actor (not necessarily a participant)
to \texttt{Notify} the contract.
\end{itemize}
\item \texttt{Pay} -- immediately makes a payment between accounts of the
contract, or from an account of the contract to a given participant.
The amount transferred is specified as a \texttt{Value}.
\end{itemize}

\subsection{Semantics\label{subsec:Marlowe-Semantics}}

As we mentioned in the previous section, Marlowe
contracts are passive: their code is executed as part of the validation of
transactions that are submitted to the blockchain. Transactions
need to be submitted by participants or their representatives (e.g.
user wallets) and validation is atomic and deterministic.

Each transaction may include a list of inputs, a set of signatures,
a slot interval, a set of input UTxOs (incoming money and tokens), and a
set of outputs (outgoing money and tokens). We use a slot interval because
it is very difficult to know the exact slot in which the transaction will
be included in practice. For a transaction to be valid in Marlowe, the
transaction must have the same effect for every slot within that slot
interval (be deterministic). For example, if a transaction has a minimum
slot number lower than timeout, and a maximum slot that is greater, then the transaction will fail with the error \texttt{AmbiguousSlotInterval}.

A key aspect of the Marlowe semantics is that it checks that a particular
transaction is valid given the current state and contract. Because
transactions are deterministic, there should be no reason why someone
accidentally sends a transaction that is invalid for a given \texttt{State}
and \texttt{Contract}, since it will only result in a cost to that participant.
However, it is still possible that, due to a race condition, a participant will send a
transaction that no longer applies to a running \texttt{Contract} and
\texttt{State}, but such a transaction would simply be ignored by the
blockchain.

The type signature of the transaction validation function is:

\begin{verbatim}
computeTransaction :: TransactionInput -> State -> Contract
                   -> TransactionOutput 
\end{verbatim}

This function can be factored into four main functions:
\begin{itemize}
\item \texttt{reduceContractStep} - this function executes the topmost
construct that does not require an input to be executed (i.e: anything
but a \texttt{When} that has not expired or a \texttt{Close} when
accounts are empty). It only simplifies the \texttt{When} construct
if it has expired (i.e. the timeout specified in the \texttt{When}
is less than or equal to the minimum slot number). In the case of
the \texttt{Close} contract, it only refunds one of the accounts at
each invocation.
\item \texttt{reduceContractUntilQuiescent} - this function calls \texttt{reduceContractStep}
repeatedly until it has no further effect,
\item \texttt{applyInput} - this function processes one single input.
The topmost construct must be a \texttt{When} that
is expecting that particular input and has not expired. 
\item \texttt{applyAllInputs} - this function processes a list of inputs.
It calls \texttt{applyInput} for each of the inputs in the list, and
calls \texttt{reduceContractUntilQuiescent} before and after every
call to \texttt{applyInput}.
\end{itemize}
The \texttt{State} stores information about the amount of money and
tokens in the contract at a given time, together with the choices
made, \texttt{Let} bindings made, and a lower bound for the current
slot:

\begin{verbatim}
data State = State { accounts    :: Map AccountId Money
                   , choices     :: Map ChoiceId ChosenNum
                   , boundValues :: Map ValueId Integer
                   , minSlot     :: Slot }
\end{verbatim}

\subsection{Extra considerations\label{subsec:Extra-considerations}}

Many of the design decisions behind Marlowe have been made with the
aim of preventing potential errors. For example:
\begin{itemize}
\item \textbf{Classification of money and tokens into accounts} separates concerns.
A Marlowe contract will never spend more money or tokens than there are in an
account, even if there is more available in the contract. But a payment
for more than there is will not fail, it will pay as much as
is available, in order to remain as close as possible
to the original intention of the contract.
\item \textbf{Account identifiers include an account owner}. An account owner
is a participant that will get the money or tokens remaining in an account
when a contract terminates. At the same time, the only construct that
can pause the execution of a contract is the \texttt{When} construct,
which has a timeout, this ensures that all contracts eventually expire
and terminate. Together, these properties ensure that no money or tokens
are locked in the contract forever.
\item \textbf{No negative deposits or payments}. Marlowe treats negative
amounts in deposits and payments as zero. At the same time,
if there happens to be a request for a deposit with a negative amount,
the contract will still wait for a null deposit to
be made, and it will continue as if everything is correct. This way execution
of the contract is disturbed as little as possible.
\item \textbf{Upper limit in the number of inputs} that a Marlowe contract
can accept throughout its lifetime. This limit is implied by the path with
maximum number of nested \texttt{When} constructs in the contract, since only
one input per \texttt{When} can be accepted. At the same time, transactions
with no effect on the contract are invalid, thus there is
a limit on the maximum number of transactions a contract can accept
throughout its life too. This bound prevents DoS attacks, and it makes static analysis
easier. We discuss further in Section~\ref{sec:Making-Marlowe-symbolic}.
\end{itemize}

\section{Making Marlowe semantics symbolic\label{sec:Making-Marlowe-symbolic}}

In this section, we briefly present and reflect on a technique that
can be used to convert a concrete implementation of a Haskell function
into a symbolic one by using the SBV library \cite{erkok2019sbv}, and to use this symbolic
implementation for static analysis. In particular, we explore this
technique in the context of the Marlowe.

This approach corresponds to our first attempt at implementing static
analysis for Marlowe contracts, and it is a systematic approach that
can be carried out with very few assumptions. 

\subsection{Overview}

The SBV library supports implementing Haskell functions in a way that
the same implementation can be used:
\begin{itemize}
\item With concrete parameters, as a normal Haskell function.
\item With symbolic parameters, so that properties can be checked for satisfiability
using an SMT solver.
\item As part of QuickCheck properties, for random testing.
\end{itemize}
Parameters that can be used symbolically are wrapped in a monad called
\texttt{SBV}. Values that depend on symbolic values must also be wrapped in the \texttt{SBV} monad.


Our semantics transaction processing function would thus become:

\begin{verbatim}
computeTransaction :: SBV TransactionInput -> SBV State
                   -> SBV Contract -> SBV TransactionOutput
\end{verbatim}

We just need a function \texttt{playTrace} that takes a list of
transactions and calls \texttt{computeTransaction} for each. 
We can then write our property to state that the output of
\texttt{playTrace} does not have any failed payments (or other warnings). We
can ask SBV to find an input transaction list that breaks the property.
However, there are a couple of issues with this approach,
we review them in Section~\ref{subsec:considerations}.

\subsection{Additional considerations\label{subsec:considerations}}

At the time of writing, SBV does not fully support complex custom data types,
but it provides symbolic versions for \texttt{Either} and \texttt{Tuple} types.
Our original implementation of Marlowe's static analysis overcomes this limitation
by generating conversion functions using using Template Haskell
\cite{sheard2002template}. This allows static analysis to remain similar to the semantics. For example, the following data structure:

\begin{verbatim}
data Input = IDeposit AccountId Party Money
           | IChoice ChoiceId ChosenNum
           | INotify
\end{verbatim}

Would be translated to the following type synonym:

\begin{verbatim}
type SInput = SBV (Either (AccountId, Party, Money)
                          (Either (ChoiceId, ChosenNum)
                                  ()))
\end{verbatim}

But this approach cannot address recursive datatypes, let alone mutually
recursive datatypes. And the \texttt{Contract} definition uses mutual recursion.

Even if we could use symbolic corecursive datatypes, SMT solvers have another
general limitation: if termination of a function is not bounded
by a concrete value, SMT solvers may not terminate when determining
the satisfiability of a property about the function.
We discuss how to address this in Section~\ref{subsec:Adapting-the-semantics}.

\subsection{Adapting the semantics\label{subsec:Adapting-the-semantics}}

In order to guarantee termination of the analysis, we need a
concrete bound. Related work often addresses this problem by
manually establishing an artificial bound on the amount of computation,
e.g: limiting the number of computation steps analysed,
the number of times loops are unrolled \cite{clarke2004tool,gulwani2008program,jackson2000finding}.

Marlowe has natural bounds, given a concrete contract, we can infer:
\begin{itemize}
\item The maximum number of inputs that can have an effect on the contract
\item The maximum number of transactions that can have an effect on the
contract
\item All of the account, choice, and \texttt{Let} identifiers that will
be used in the contract
\item The number of participants that will participate in the contract
\end{itemize}
From this data, we can also deduce an upper bound for:
\begin{itemize}
\item The number of times that
\texttt{computeTransaction}, \texttt{reduceContractStep}, and \texttt{applyInput} may
be called.
\item The number of accounts that the contract will use, and
the number of elements there may be in each of the associative maps
that comprise the \texttt{State} of the contract at any given point
of the execution.
\end{itemize}
Marlowe \texttt{Contract}s are finite, and every call to
\texttt{reduceContractStep} will either make no progress or
remove one of the constructs, with the exception of \texttt{Close}.
In the case of \texttt{Close}, every call to \texttt{reduceContractStep} refunds
one account, and the number of accounts is also bounded, since each
needs to be mentioned in the \texttt{Contract}. Thus, the symbolic transaction
processing function becomes:

\begin{verbatim}
computeTransaction :: SBV TransactionInput -> SBV State
                   -> Contract -> SBV TransactionOutput
\end{verbatim}

There is one more problem: the output \texttt{Contract} returned
by the function, which is wrapped inside the \texttt{TransactionOutput},
is symbolic, since it depends on the current \texttt{TransactionInput}
and \texttt{State}, which are both symbolic.

We get around this by using a continuation style. Instead
of returning the \texttt{TransactionOutput}, we take a continuation
function that takes the concrete \texttt{Contract} and the symbolic version
of \texttt{TransactionOutput} without the \texttt{Contract}.

Thus, the symbolic transaction processing function will look something
like:

\begin{verbatim}
computeTransaction :: SymVal a => SBV TransactionInput
                   -> SBV State -> Contract
                   -> (SBV TransactionOutput -> Contract -> SBV a)
                   -> SBV a
\end{verbatim}

In practice, we also include some extra information about bounds,
and we make some other parts of \texttt{TransactionOutput} concrete.

\section{Making static analysis more efficient\label{sec:Making-static-analysis-efficient}}

In this section, we explain the optimisation techniques in more detail,
and we illustrate them with examples of their application to Marlowe's static analysis.

\subsection{Lightweight modifications\label{subsec:Lightweight-modifications}}

Lightweight modifications are local, which means it is less likely that we
will introduce reasoning errors when implementing them.

\subsubsection{Removing unnecessary parts from the analysis.}

When we use the same or similar code for both the analysis and the
implementation, we may end up including code that is not relevant
to the analysis.

In the case of Marlowe, this was the case of the \texttt{Close} construct.
The \texttt{Close} construct refunds all the money and tokens remaining
in the accounts. The number of times that \texttt{reduceContractStep} needs
to be called depends on how many accounts have money left, and because
this information is symbolic, there are many potential ways in which execution
can unfold. All these paths need to be represented as constraints, which
makes analysing \texttt{Close} very costly.

Fortunately, as it turns out, we do not need to analyse \texttt{Close} at all.
Because it is impossible for the \texttt{Close} construct to produce a failed payment
or any other warning (we have proven this\footnote{\url{https://github.com/input-output-hk/marlowe/blob/master/isabelle/CloseSafe.thy} (last visited on 04/04/2020)} using Isabelle \cite{nipkow2002isabelle}). \texttt{Close} only pays as much as available,
so we can safely remove it from the analysis.

\subsubsection{Avoiding high level abstractions.}

High level libraries like SBV, and even standards like SMTLib, support
the use and construction of high level abstractions,
e.g: custom data-types, list, sets\dots{} Unfortunately, even though
high level abstractions aid reasoning about code, they often
prevent optimisations, since they abstract out aspects that
in our particular case may be concrete.

For example, in the case of Marlowe's static analysis, we initially
implemented a \emph{symbolic} associative map primitive with the only limitation
that it needed a concrete bound in the number of elements. This is
straightforward to realise using the symbolic implementation of list
and tuple, both provided by SBV. However, because we assumed keys
were symbolic, looking up a single element required constraints that
compared the element with every key up to the maximum capacity of
the associative map.

Nevertheless, in Marlowe we know the values of all the keys that we are
going to use in maps, because the contract is concrete, and only \texttt{Account},
\texttt{Choice}, and \texttt{Let} identifiers that are mentioned in
the contract will ever make it into the \texttt{State}. So we do not
need keys of the associative map to be symbolic, we can use a concrete
associative map with symbolic values.

\subsubsection{Reducing the search space by normalising parameters.
\label{subsec:Reducing-search-space-by-normalising-parameters}}

The higher the number of degrees of freedom of the input, the larger
the search space, and the higher the load we are putting on the SMT
solver. But, if two or more different inputs have the same effect on the
property we only need to include one of them.

For example, in the case of Marlowe's static analysis,
Marlowe allows several inputs to be combined into a single transaction.
This functionality is important because each transaction requires
the issuer to pay fees. On the other hand, it also means
that static analysis must consider many more possibilities, since
the number of ways of partitioning inputs is exponential
in the number of inputs.

However, we can devise a normal form for input traces, in which there
is a maximum of one input per transaction. We only need to make sure
that, for every trace, if it produces a warning, there exists a trace
with only one input per transaction that also produces a warning.
Using the automated proof assistant Isabelle \cite{nipkow2002isabelle},
we have shown that, indeed, splitting transactions into transactions
with single inputs and the same slot interval as the original transactions
does not modify the effect of those transactions on a contract\footnote{\url{https://github.com/input-output-hk/marlowe/blob/master/isabelle/SingleInputTransactions.thy}
(last visited on 29/04/2020)}.

This optimization reduces the search space, but transactions may still
have either one or zero inputs, so there are still many ways of distributing
the inputs in transactions. We explain how we reduced
the search space further in Section~\ref{subsec:Heavyweight-modifications}. 

\subsection{Heavyweight modifications. \label{subsec:Heavyweight-modifications}}

When optimising, if our solution is a local minimum, small changes
to the parameters will not grant any improvement to the result.
For that reason, in this section, we explore ways of optimising that
may imply considerable rewriting of our properties, constraints, and
static analysis implementation in general.

Unfortunately, not following the concrete implementation closely is
much more error prone, since there are many
more assumptions that we need to make and reason about.
In Section~\ref{sec:Testing}, we explore ways of mitigating this issue.

\subsubsection{Reducing the search space by using normalised execution paths relevant
to the property. \label{subsec:Reducing-search-space-by-using-normalised-execution-paths-relevant-to-the-property}}

Instead of modelling the execution symbolically, we can focus on modelling
the property. We do not even need to consider the
representation of the counterexamples (we will discuss that in the next section),
but only in what are the conditions for the property to be false.

For example, the main property we want to check is whether there is
any possible execution that produces a failed payment. Thus, we only
write constraints for executions in which this can happen instead of
modelling all possibilities.
The most complicated construct in terms of execution is the \texttt{When}
construct, since it allows for transactions that are separate in time
to have different effects depending on when they are issued, all other
constructs will get resolved atomically in one way or another. Without
loss of generality, we can structure possible executions as shown in
Figure~\ref{fig:Distribution-of-transactions}: we can conceptually break
the contract tree into subtrees, where each subtree has a \texttt{When}
construct as its root, with the exception of the subtree at the root
of the original tree.

\begin{figure}
\center
\includegraphics[width=0.7\textwidth]{figures/transactions}

\caption{Distribution of transactions with respect to a contract\label{fig:Distribution-of-transactions}}

\end{figure}

Each level of subtrees corresponds to a potential transaction, i.e: the
root subtree will correspond to the first transaction, the set of
subtrees that are children of the first subtree (in the original tree)
will correspond to the second transaction, and so on. There may be
paths which require fewer transactions/subtrees because they traverse
fewer \texttt{When} constructs.

We split transactions like this because if the maximum slot number of
a transaction is lower than the slot number in the timeout of a \texttt{When}
it will stop before executing that \texttt{When}. Since the \texttt{When}
and its continuation may be executed by a different transaction, the
slot numbers for that segment of execution may be different, which means
the values of \texttt{Value}s may be different, which means the amounts
in payments and deposits may be different, and thus the warnings issued may
be different as if both segments were executed by the same transaction.

However, there is an edge case: a transaction may execute past 
a \texttt{When} if the minimum slot number in the transaction is greater
or equal than the timeout of the \texttt{When}. If the transaction expires
the \texttt{When} we can no longer separate the execution before the
\texttt{When} and after the \texttt{When} into two different transactions,
because we know that the timeout branch of the \texttt{When} will be executed
as part of the first transaction, and thus it will use the slot interval
of the first transaction (same used for the first segment).

This is not only true for the timeout branch, if we include
an input that is allowed by a \texttt{When}, then the first transaction
will continue into the corresponding \texttt{When}
branch, and we will not use a second transaction.

We cannot just constrain the maximum slot number of the first transaction
to be less than the timeout in the \texttt{When} because, if we do
that, then we will miss executions where one transaction expires several
\texttt{When} in a row, or where it expires one \texttt{When} and provides
the right input for a later \texttt{When}. And we cannot just not constrain
the maximum slot number of the first transaction because then we will
be considering impossible executions.

We get around this problem by allowing the slot numbers of the first
and second transactions to be equal. If this happens, we will find
out that one of the transactions will be marked as \texttt{UselessTransaction}
by the semantics when we look at the counterexample. So we just need
to filter out all transactions that produce \texttt{UselessTransaction}
warnings in the final result.

To sum up, in Section~\ref{subsec:Reducing-search-space-by-normalising-parameters}, we already limited the number of inputs per transaction
to a maximum of one. But now we have also assigned each of the
transactions to a part of the contract, so we no longer need a symbolic
list of transactions, we can use a finite concrete list of symbolic
transactions.

One detail we found out during testing is that, even though a \texttt{When}
belongs to the beginning of a transaction, the environment used by
the \texttt{Observation}s in the \texttt{Notify} cases of the \texttt{When}
correspond to the \texttt{State} before the \texttt{When} is executed (except
for the slot interval). The same is true for the \texttt{Value} in the
\texttt{Deposit} cases, since the amount to deposit must be calculated without
considering the effects of the deposit itself.

\subsubsection{Minimizing the representation of inputs and outputs.}

When we initially implemented the efficient version of static analysis
for Marlowe, we did not pay any attention to the inputs and outputs.
The first version would simply take a concrete \texttt{Contract}
as input, and it would return a symbolic Boolean that determined whether
the \texttt{Contract} was valid or not. However, if a \texttt{Contract}
turns out to be invalid, we will also want to know why, so we later modified
the property to give a counterexample that illustrated what went wrong.
The original implementation still used some intermediate symbolic
variables, but they were anonymous, and they were created during the
exploration of the contract.

A simple way of obtaining a counterexample is to modify the output
of the function to return the offending trace using the symbolic \texttt{Maybe}
type. Surprisingly, this change increases the time
required by the symbolic analysis severalfold.

An efficient way of extracting counterexample information was to
pass a symbolic fixed-size list, as input to the static analysis, where
each element corresponds to a transaction and consists of a tuple with four symbolic integers:
\begin{enumerate}
\item An integer representing the minimum slot
\item An integer representing the maximum slot
\item An integer representing the \texttt{When} case whose input is being
included in the transaction, where zero represents the timeout branch (and no input).
\item An integer representing the amount of money or tokens (if the input
is a \texttt{Deposit}), or the number chosen (if the input is a \texttt{Choice})
\end{enumerate}
For short branches (that require fewer transactions) we pad the end of
the list with dummy transactions with all four numbers set to $-1$.

In order to translate this sequence of numbers into a proper list
of transactions that is human readable and we can use to report the
counter example, we need to use the concrete semantics together with
the information obtained from the static analysis to \emph{fill the gaps},
by iterating through the list and looking at the evolution
of the contract with each transaction.
This provides us with the rest of necessary information, such as
the type of a transaction input (e.g: whether it is a \texttt{Deposit} or a \texttt{Choice}). We also use this process to filter transactions with no effect,
i.e: they produce \texttt{UselessTransaction} as we mentioned in Section~\ref{subsec:Reducing-search-space-by-using-normalised-execution-paths-relevant-to-the-property}.

We also use this separation of concerns between static analysis and
concrete semantics as an opportunity for applying
property based testing.%, as we explain in Section~\ref{subsec:Testing-for-consistency}.

\section{Testing for consistency and equivalence\label{sec:Testing}}

The more different the static analysis implementation and the concrete
implementation are, the harder it is to ensure they are consistent with
each other. To ensure that heavyweight optimisations remain consistent,
we combine the use of automated proof assistants and the use of property based testing.

\subsection{Testing for consistency\label{subsec:Testing-for-consistency} }

If our static analysis does not replicate all the functionality of
the semantics, we can use potential discrepancies as an opportunity
for testing, as shown in Figure~\ref{fig:Property-based-testing-for-consistency}.
We generate random contracts and we apply the static analysis to them
in order to try to find a counterexample that produces warnings. If
we cannot find any counterexamples then the test passes, but if we
find one, we can test it on the semantics and see whether the counterexample
indeed produces warnings in the semantics too, if it does not we have
found a problem in either the static analysis or the semantics.

A limitation of this approach is that it only tests for false positives; 
false negatives can be detected by testing
for equivalence (see Section~\ref{subsec:Testing-for-equivalence}).

In addition, we can add assertions to the process. In the case of
Marlowe, if the counterexample causes errors during the execution or is
formed incorrectly, it would also mean that there is a problem with
the static analysis. For example, it may be that the counterexample
refers to a \texttt{Case} of a \texttt{When} that does not exist,
or that it has invalid or ambiguous intervals. If it has \texttt{UselessTransactions}
that is ok, because we are doing that on purpose, as we mentioned in Section~\ref{subsec:Reducing-search-space-by-using-normalised-execution-paths-relevant-to-the-property}.

\begin{figure}[h]
\centering
\begin{minipage}{.4\textwidth}
    \begin{centering}
    \includegraphics[width=0.8\textwidth]{figures/consistency_property}
    \par\end{centering}
    \caption{Testing for consistency\label{fig:Property-based-testing-for-consistency}}
\end{minipage}%
\hspace{0.08\textwidth}
\begin{minipage}{.4\textwidth}
    \begin{centering}
    \includegraphics[width=0.7\textwidth]{figures/equivalence_property}
    \par\end{centering}
    \caption{Testing for equivalence\label{fig:Property-based-testing-for-equivalence}}
\end{minipage}
\end{figure}

\vspace*{-5mm}

\subsection{Testing for equivalence\label{subsec:Testing-for-equivalence} }

Given two  implementations of the static analysis, we have another opportunity
for testing. We have one efficient implementation that
is very different from the semantics and one inefficient implementation
that is much closer to the semantics, and we can compare the results of the
two, as shown in Figure~\ref{fig:Property-based-testing-for-equivalence}.

We generate random contracts using a custom QuickCheck \cite{quickcheck} generator,
 feed them to both implementations, and compare the results.
If the results are the same then test passes, if they are different then
one of the implementations is wrong.
This approach covers both types of errors, i.e: false positives and
false negatives (for both of the implementations), but the execution
time of the tests is bounded from below by the slower of the two implementations.
The consistency approach is thus more efficient in finding false positives.

\section{Measurements \label{sec:Measurements} }

In our experiments, the heavyweight optimisations considerably reduced
the requirements of both processing time and memory for Marlowe's static
analysis. %In Tables~\ref{table1},~\ref{table2},~\ref{table3},~and~\ref{table4},
We present below the results of measuring the performance of static analysis on
four example  contracts,
before\footnote{\url{https://github.com/input-output-hk/marlowe/blob/master/src/Language/Marlowe/Analysis/FSSemantics.hs} [last visited 19-05-2020]}
and after\footnote{\url{https://github.com/input-output-hk/marlowe/blob/master/src/Language/Marlowe/Analysis/FSSemanticsFastVerbose.hs} [last visited 19-05-2020]}
the heavyweight optimisations.

Unfortunately, at the time of writing, we do not have a completely unoptimised
version of the static analysis that we can use to compare, because the semantics
of Marlowe have changed since we implemented that version. However, our impression
from manual testing is that the impact of lightweight optimisations was much more modest than the impact of heavyweight optimisations.

Using the \texttt{perf} tool \cite{perf}, we measured the execution
time\footnote{The experiments were run on a laptop computer with a
i9-9900K (3.6GHz) processor and two modules of 16GB of SODIMM DDR4 RAM at 2400MHz.}
and the overhead of the generation of the constraints and their solution
by Z3 \cite{de2008z3}. We also measured the peak RAM usage of the whole
process using GNU's \texttt{time} tool \cite{keppel1998gnu}.

In all cases the implementation with the heavyweight optimisations
performs much better and scales further. In the case of the \textit{auction}
and \textit{crowdfunding} contracts, whose size grows exponentially, both
approaches quickly overwhelm the resources available in the execution environment.
In the case of \textit{rent} and \textit{coupon bond} contracts,
which grow linearly, when using the lightweight version the problem becomes 
intractable much faster than with the heavyweight one.

\begin{table}[b]
\centering
\scalebox{0.8}{
\begin{tabular}{l||lllll}
\multicolumn{6}{l}{\textbf{Auction contract -- \texttt{Auction.hs}}} \\ \hline \hline
\textbf{Num.~participants}             & \multicolumn{1}{c|}{1}        & \multicolumn{1}{c|}{2}            & \multicolumn{1}{c|}{3}                         & \multicolumn{1}{c|}{4}                        & \multicolumn{1}{c}{5}    \\ \hline
\textbf{Contract size (chars)}         & \multicolumn{1}{c|}{275}        & \multicolumn{1}{c|}{3,399}     & \multicolumn{1}{c|}{89,335}    & \multicolumn{1}{c|}{4,747,361}      & \multicolumn{1}{c}{413,784,559} \\ \hline \hline
\multicolumn{6}{c}{\textbf{Lightweight optimisations}} \\ \hline \hline
\textbf{Execution time}                & \multicolumn{1}{c|}{0.2205s}  & \multicolumn{1}{c|}{4m 45.2015s}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Generation overhead                    & \multicolumn{1}{c|}{76.61\%}  & \multicolumn{1}{c|}{96.40\%}      & \multicolumn{1}{c|}{\color[HTML]{888888} N/A}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.1689s}  & \multicolumn{1}{c|}{4m 34.9342s}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Z3 overhead                            & \multicolumn{1}{c|}{23.39\%}  & \multicolumn{1}{c|}{3.60\%}       & \multicolumn{1}{c|}{\color[HTML]{888888} N/A}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.0516s}  & \multicolumn{1}{c|}{10.2673s}     & \multicolumn{1}{c|}{\color[HTML]{888888} N/A}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\textbf{RAM usage peak}                & \multicolumn{1}{c|}{44,248KB} & \multicolumn{1}{c|}{1,885,928KB}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline \hline
\multicolumn{6}{c}{\textbf{Heavyweight optimisations}} \\ \hline \hline
\textbf{Execution time}                & \multicolumn{1}{c|}{0.01198s}   & \multicolumn{1}{c|}{0.0289s}   & \multicolumn{1}{c|}{1.1138s}   & \multicolumn{1}{c|}{1h 5m 45.1377s} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Generation overhead                    & \multicolumn{1}{c|}{16.27\%}    & \multicolumn{1}{c|}{29.64\%}   & \multicolumn{1}{c|}{24.09\%}   & \multicolumn{1}{c|}{80.86\%}        & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.001949s}  & \multicolumn{1}{c|}{0.008566s} & \multicolumn{1}{c|}{0.268314s} & \multicolumn{1}{c|}{53m 10.038344s} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Z3 overhead                            & \multicolumn{1}{c|}{83.73\%}    & \multicolumn{1}{c|}{70.36\%}   & \multicolumn{1}{c|}{75.91\%}   & \multicolumn{1}{c|}{19.14\%}        & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.010031s}  & \multicolumn{1}{c|}{0.020334s} & \multicolumn{1}{c|}{0.845486s} & \multicolumn{1}{c|}{12m 35.099356s} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\textbf{RAM usage peak}                & \multicolumn{1}{c|}{17,020KB}   & \multicolumn{1}{c|}{17,740KB}  & \multicolumn{1}{c|}{49,668KB}  & \multicolumn{1}{c|}{2,364,500KB}    & \multicolumn{1}{c}{\color[HTML]{888888} N/A}
\end{tabular}
}
%\caption{Execution cost measurement of auction contract\label{table1}}
\end{table}

\begin{table}[]
\centering
\scalebox{0.8}{
\begin{tabular}{l||lllll}
\multicolumn{6}{l}{\textbf{Crowdfunding contract -- \texttt{CrowdFunding.hs}}} \\ \hline \hline
\textbf{Num.~participants}             & \multicolumn{1}{c|}{1}         & \multicolumn{1}{c|}{2}            & \multicolumn{1}{c|}{3}                        & \multicolumn{1}{c|}{4}                        & \multicolumn{1}{c}{5}    \\
\hline
\textbf{Contract size (chars)}         & \multicolumn{1}{c|}{857}      & \multicolumn{1}{c|}{12,704}   & \multicolumn{1}{c|}{364,824}  & \multicolumn{1}{c|}{19,462,278}   & \multicolumn{1}{c}{1,690,574,798} \\ \hline \hline
\multicolumn{6}{c}{\textbf{Lightweight optimisations}} \\ \hline \hline
\textbf{Execution time}                & \multicolumn{1}{c|}{0.6298s}   & \multicolumn{1}{c|}{50m 53.4597s} & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Generation overhead                    & \multicolumn{1}{c|}{85.02\%}   & \multicolumn{1}{c|}{99.82\%}      & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.5356s}   & \multicolumn{1}{c|}{50m 47.9635s} & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Z3 overhead                            & \multicolumn{1}{c|}{14.98\%}   & \multicolumn{1}{c|}{0.18\%}       & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.0943s}   & \multicolumn{1}{c|}{5.4962s}      & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\textbf{RAM usage peak}                & \multicolumn{1}{c|}{111,980KB} & \multicolumn{1}{c|}{5,641,056KB}  & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c|}{\color[HTML]{888888} N/A} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline \hline
\multicolumn{6}{c}{\textbf{Heavyweight optimisations}} \\ \hline \hline
\textbf{Execution time}                & \multicolumn{1}{c|}{0.0125s}  & \multicolumn{1}{c|}{0.041s}   & \multicolumn{1}{c|}{1.0515s}  & \multicolumn{1}{c|}{32m 15.4478s} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Generation overhead                    & \multicolumn{1}{c|}{16.68\%}  & \multicolumn{1}{c|}{25.36\%}  & \multicolumn{1}{c|}{37.23\%}  & \multicolumn{1}{c|}{69.83\%}      & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.0021s}  & \multicolumn{1}{c|}{0.0104s}  & \multicolumn{1}{c|}{0.3915s}  & \multicolumn{1}{c|}{22m 31.5232s} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Z3 overhead                            & \multicolumn{1}{c|}{83.32\%}  & \multicolumn{1}{c|}{74.64\%}  & \multicolumn{1}{c|}{62.77\%}  & \multicolumn{1}{c|}{30.17\%}      & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.0104s}  & \multicolumn{1}{c|}{0.0306s}  & \multicolumn{1}{c|}{0.6600s}  & \multicolumn{1}{c|}{9m 43.9246s}  & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\textbf{RAM usage peak}                & \multicolumn{1}{c|}{17,016KB} & \multicolumn{1}{c|}{18,768KB} & \multicolumn{1}{c|}{62,108KB} & \multicolumn{1}{c|}{3,715,020KB}  & \multicolumn{1}{c}{\color[HTML]{888888} N/A}
\end{tabular}
}
%\caption{Execution cost measurement of crowdfunding contract\label{table2}}
\end{table}

\begin{table}[]
\centering
\scalebox{0.8}{
\begin{tabular}{l||lllll}
\multicolumn{6}{l}{\textbf{Rent contract -- \texttt{Rent.hs}}} \\ \hline \hline
\textbf{Num.~months}                   & \multicolumn{1}{c|}{1}        & \multicolumn{1}{c|}{2}         & \multicolumn{1}{c|}{3}           & \multicolumn{1}{c|}{4}               & \multicolumn{1}{c}{5}    \\ \hline
\textbf{Contract size (chars)}         & \multicolumn{1}{c|}{339}      & \multicolumn{1}{c|}{595}      & \multicolumn{1}{c|}{852}      & \multicolumn{1}{c|}{1,109}    & \multicolumn{1}{c}{1,366} \\ \hline \hline
\multicolumn{6}{c}{\textbf{Lightweight optimisations}} \\ \hline \hline
\textbf{Execution time}                & \multicolumn{1}{c|}{0.2850s}  & \multicolumn{1}{c|}{3.0303s}   & \multicolumn{1}{c|}{2m 53.2458s} & \multicolumn{1}{c|}{3h 22m 13.0122s} & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Generation overhead                    & \multicolumn{1}{c|}{77.55\%}  & \multicolumn{1}{c|}{91.25\%}   & \multicolumn{1}{c|}{99.18\%}     & \multicolumn{1}{c|}{99.94\%}         & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.2210s}  & \multicolumn{1}{c|}{2.7651s}   & \multicolumn{1}{c|}{2m 51.8252s} & \multicolumn{1}{c|}{3h 22m 5.7324s}  & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
Z3 overhead                            & \multicolumn{1}{c|}{22.45\%}  & \multicolumn{1}{c|}{8.75\%}    & \multicolumn{1}{c|}{0.82\%}      & \multicolumn{1}{c|}{0.06\%}          & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.0640s}  & \multicolumn{1}{c|}{0.2652s}   & \multicolumn{1}{c|}{1.4206s}  & \multicolumn{1}{c|}{7.2798s}         & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline
\textbf{RAM usage peak}                & \multicolumn{1}{c|}{42,052KB} & \multicolumn{1}{c|}{221,960KB} & \multicolumn{1}{c|}{1,237,092KB} & \multicolumn{1}{c|}{9,160,616KB}     & \multicolumn{1}{c}{\color[HTML]{888888} N/A} \\ \hline \hline
\multicolumn{6}{c}{\textbf{Heavyweight optimisations}} \\ \hline \hline
\textbf{Execution time}                & \multicolumn{1}{c|}{0.0114s}  & \multicolumn{1}{c|}{0.0111s}  & \multicolumn{1}{c|}{0.01132s} & \multicolumn{1}{c|}{0.01124s} & \multicolumn{1}{c}{0.01255s} \\ \hline
Generation overhead                    & \multicolumn{1}{c|}{11.55\%}  & \multicolumn{1}{c|}{11.95\%}  & \multicolumn{1}{c|}{13.65\%}  & \multicolumn{1}{c|}{13.69\%}  & \multicolumn{1}{c}{21.00\%} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.0013s}  & \multicolumn{1}{c|}{0.0013s}  & \multicolumn{1}{c|}{0.0015s}  & \multicolumn{1}{c|}{0.0015s}  & \multicolumn{1}{c}{0.0026s} \\ \hline
Z3 overhead                            & \multicolumn{1}{c|}{88.45\%}  & \multicolumn{1}{c|}{88.05\%}  & \multicolumn{1}{c|}{86.35\%}  & \multicolumn{1}{c|}{86.31\%}  & \multicolumn{1}{c}{79.00\%} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.0101s}  & \multicolumn{1}{c|}{0.0098s}  & \multicolumn{1}{c|}{0.0098s}  & \multicolumn{1}{c|}{0.0097s}  & \multicolumn{1}{c}{0.0099s} \\ \hline
\textbf{RAM usage peak}                & \multicolumn{1}{c|}{15,536KB} & \multicolumn{1}{c|}{15,364KB} & \multicolumn{1}{c|}{15,400KB} & \multicolumn{1}{c|}{15,364KB} & \multicolumn{1}{c}{15,540KB}

\end{tabular}
}
%\caption{Execution cost measurement of crowdfunding contract\label{table3}}
\end{table}

\begin{table}[]
\centering
\scalebox{0.8}{
\begin{tabular}{l||lllll}
\multicolumn{6}{l}{\textbf{Coupon bond contract - \texttt{CouponBond.hs}}} \\ \hline \hline
\textbf{Num.~months}                   & \multicolumn{1}{c|}{2}        & \multicolumn{1}{c|}{3}         & \multicolumn{1}{c|}{4}           & \multicolumn{1}{c|}{5}            & \multicolumn{1}{c}{6}    \\ \hline
\textbf{Contract size (chars)}         & \multicolumn{1}{c|}{479}      & \multicolumn{1}{c|}{635}      & \multicolumn{1}{c|}{791}      & \multicolumn{1}{c|}{947}      & \multicolumn{1}{c}{1,103} \\ \hline \hline
\multicolumn{6}{c}{\textbf{Lightweight optimisations}} \\ \hline \hline
\textbf{Execution time}                & \multicolumn{1}{c|}{0.8293s}  & \multicolumn{1}{c|}{5.8887s}   & \multicolumn{1}{c|}{1m 35.3930s} & \multicolumn{1}{c|}{26m 36.4585s} & \multicolumn{1}{c}{9h 50m 22.3418s} \\ \hline
Generation overhead                    & \multicolumn{1}{c|}{76.57\%}  & \multicolumn{1}{c|}{74.91\%}   & \multicolumn{1}{c|}{89.29\%}     & \multicolumn{1}{c|}{72.34\%}      & \multicolumn{1}{c}{76.66\%} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.6350s}  & \multicolumn{1}{c|}{4.4112s}   & \multicolumn{1}{c|}{1m 25.1764s} & \multicolumn{1}{c|}{19m 14.8781s} & \multicolumn{1}{c}{7h 32m 34.7672s} \\ \hline
Z3 overhead                            & \multicolumn{1}{c|}{23.43\%}  & \multicolumn{1}{c|}{25.09\%}   & \multicolumn{1}{c|}{10.71\%}     & \multicolumn{1}{c|}{27.66\%}      & \multicolumn{1}{c}{23.34\%} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.1943s}  & \multicolumn{1}{c|}{1.4775s}   & \multicolumn{1}{c|}{10.2166s}    & \multicolumn{1}{c|}{7m 21.5804s}  & \multicolumn{1}{c}{2h 17m 47.5746s} \\ \hline
\textbf{RAM usage peak}                & \multicolumn{1}{c|}{74,180KB} & \multicolumn{1}{c|}{209,724KB} & \multicolumn{1}{c|}{940,924KB}   & \multicolumn{1}{c|}{3,283,384KB}  & \multicolumn{1}{c}{13,483,908KB} \\ \hline \hline
\multicolumn{6}{c}{\textbf{Heavyweight optimisations}} \\ \hline \hline
\textbf{Execution time}                & \multicolumn{1}{c|}{0.0092s}  & \multicolumn{1}{c|}{0.0095s}  & \multicolumn{1}{c|}{0.0097s}  & \multicolumn{1}{c|}{0.0102s}  & \multicolumn{1}{c}{0.0105s} \\ \hline
Generation overhead                    & \multicolumn{1}{c|}{14.51\%}  & \multicolumn{1}{c|}{15.50\%}  & \multicolumn{1}{c|}{15.51\%}  & \multicolumn{1}{c|}{19.71\%}  & \multicolumn{1}{c}{19.69\%} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.0013s}  & \multicolumn{1}{c|}{0.0015s}  & \multicolumn{1}{c|}{0.0015s}  & \multicolumn{1}{c|}{0.0020s}  & \multicolumn{1}{c}{0.0021s} \\ \hline
Z3 overhead                            & \multicolumn{1}{c|}{85.49\%}  & \multicolumn{1}{c|}{84.50\%}  & \multicolumn{1}{c|}{84.49\%}  & \multicolumn{1}{c|}{80.29\%}  & \multicolumn{1}{c}{80.31\%} \\ \hline
\multicolumn{1}{r||}{× execution time} & \multicolumn{1}{c|}{0.0079s}  & \multicolumn{1}{c|}{0.0080s}  & \multicolumn{1}{c|}{0.0082s}  & \multicolumn{1}{c|}{0.0082s}  & \multicolumn{1}{c}{0.0085s} \\ \hline
\textbf{RAM usage peak}                & \multicolumn{1}{c|}{15,636KB} & \multicolumn{1}{c|}{15,816KB} & \multicolumn{1}{c|}{15,788KB} & \multicolumn{1}{c|}{15,780KB} & \multicolumn{1}{c}{15,760KB}
\end{tabular}
}
%\caption{Execution cost measurement of coupon contract\label{table4}}
\vspace*{-0.6cm}
\end{table}


\noindent

Another conclusion that can be derived from the experiments is that, in the
version with lightweight optimisations, most of the processing time seems to be
spent generating of the constraints, and solving is done relatively
quickly by Z3; while the opposite happens for the version with heavyweight
optimisations.

These results suggest that the SBV library is able to generate constraints in a way
that they are handled efficiently by Z3, but the process itself can be costly. However, the  execution time required by Z3
is also lower in the case of the heavyweight optimisations as well as
growing more slowly, which suggests that the optimisations described here
affect both parts of the process.

\section{Related work}

Work in \cite{mokhov2019formal} documents a similar effort to ensure
correctness of control software in Haskell using the SBV library; the
authors also discuss performance of the analysis and apply this approach
to non-functional requirements.

The idea of using constraint solvers for finding bugs is not new,
and there have been a number of initiatives that have explored its
application to the verification of assertions in programs written
using general purpose programming languages \cite{gulwani2008program,jackson2000finding};
as well as for the compliance with protocols
\cite{ball2001automatically,xie2005saturn}.

\cite{keshishzadeh2013early} also applies constraint solvers for
detecting problems in the usage of DSLs. The authors observe that
SMT solvers have limited support for non-linear constraints such as
exponentiation. This problem does not affect the current design of
Marlowe because it does not support multiplication by arbitrary variables,
and because all inputs are integer and bounded finitely.




\section{Conclusion}

In this paper we have summarized our work
on optimising the static analysis for Marlowe contracts. We have seen
that there are two distinct approaches to static analysis using SMT,
both have advantages and disadvantages. One is less error prone and
straightforward, but inefficient and hard to test; the other 
is much more efficient, versatile, and testable, but more error prone.
We have also seen that many specific properties and restrictions characteristic
of the target DSL can be utilized both as optimisation opportunities
and, in our case, for completeness of the analysis. Symbolic execution
of a Turing-complete language, would be intractable,
and would require us to manually set a bound; but this is not in the
case for Marlowe.

In the end, we have illustrated how to counteract the main disadvantage
of the optimised approach -- its propensity to errors -- by using property
based testing. This way we have obtained a static analysis implementation
that is efficient, versatile, testable, and reliable. 
On the other hand, for the static analysis of Marlowe contracts, we
found out that when running statistics on the equivalence testing
property, most of the bugs were false negatives in the straightforward
implementation, and the optimised implementation seems to be more
reliable thanks to the consistency tests that we run beforehand.

Another advantage of the optimised implementation is that, because
it relies on fewer and simpler features, it is compatible with more
SMT solvers which, in turn, means that it is less reliant on the
correctness or efficiency of a single solver. If one solver fails to give
an answer, we can try another; if we want further evidence that a
contract is valid, we can test it with several solvers.

In the future, we would like to extend static analysis to cover other
potential problems in Marlowe contracts and to aid their development.
We plan to use static analysis to locate unreachable
subcontracts, to allow developers to provide custom assertions and
check their satisfiability, and to allow users to inspect the
possible maximum and minimum values that particular expressions can
reach. 


\bibliographystyle{splncs04}
\bibliography{paper}

\end{document}
