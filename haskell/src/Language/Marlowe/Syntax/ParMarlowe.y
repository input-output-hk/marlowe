-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.Marlowe.Syntax.ParMarlowe
  ( happyError
  , myLexer
  , pContract
  , pCase
  , pListCase
  , pAction
  , pValue
  , pObservation
  , pParty
  , pPayee
  , pTimeout
  , pBound
  , pListBound
  , pToken
  , pChoiceId
  , pValueId
  ) where

import Prelude

import qualified Language.Marlowe.Syntax.AbsMarlowe
import Language.Marlowe.Syntax.LexMarlowe
import qualified Data.ByteString.Char8 as BS

}

%name pContract Contract
%name pCase Case
%name pListCase ListCase
%name pAction Action
%name pValue Value
%name pObservation Observation
%name pParty Party
%name pPayee Payee
%name pTimeout Timeout
%name pBound Bound
%name pListBound ListBound
%name pToken Token
%name pChoiceId ChoiceId
%name pValueId ValueId
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('                 { PT _ (TS _ 1)  }
  ')'                 { PT _ (TS _ 2)  }
  ','                 { PT _ (TS _ 3)  }
  'Account'           { PT _ (TS _ 4)  }
  'AddValue'          { PT _ (TS _ 5)  }
  'Address'           { PT _ (TS _ 6)  }
  'AndObs'            { PT _ (TS _ 7)  }
  'Assert'            { PT _ (TS _ 8)  }
  'AvailableMoney'    { PT _ (TS _ 9)  }
  'Bound'             { PT _ (TS _ 10) }
  'Case'              { PT _ (TS _ 11) }
  'Choice'            { PT _ (TS _ 12) }
  'ChoiceId'          { PT _ (TS _ 13) }
  'ChoiceValue'       { PT _ (TS _ 14) }
  'ChoseSomething'    { PT _ (TS _ 15) }
  'Close'             { PT _ (TS _ 16) }
  'Cond'              { PT _ (TS _ 17) }
  'Constant'          { PT _ (TS _ 18) }
  'Deposit'           { PT _ (TS _ 19) }
  'DivValue'          { PT _ (TS _ 20) }
  'FalseObs'          { PT _ (TS _ 21) }
  'If'                { PT _ (TS _ 22) }
  'Let'               { PT _ (TS _ 23) }
  'MerkleizedCase'    { PT _ (TS _ 24) }
  'MulValue'          { PT _ (TS _ 25) }
  'NegValue'          { PT _ (TS _ 26) }
  'NotObs'            { PT _ (TS _ 27) }
  'Notify'            { PT _ (TS _ 28) }
  'OrObs'             { PT _ (TS _ 29) }
  'Party'             { PT _ (TS _ 30) }
  'Pay'               { PT _ (TS _ 31) }
  'Role'              { PT _ (TS _ 32) }
  'SubValue'          { PT _ (TS _ 33) }
  'TimeIntervalEnd'   { PT _ (TS _ 34) }
  'TimeIntervalStart' { PT _ (TS _ 35) }
  'Token'             { PT _ (TS _ 36) }
  'TrueObs'           { PT _ (TS _ 37) }
  'UseValue'          { PT _ (TS _ 38) }
  'ValueEQ'           { PT _ (TS _ 39) }
  'ValueGE'           { PT _ (TS _ 40) }
  'ValueGT'           { PT _ (TS _ 41) }
  'ValueLE'           { PT _ (TS _ 42) }
  'ValueLT'           { PT _ (TS _ 43) }
  'When'              { PT _ (TS _ 44) }
  '['                 { PT _ (TS _ 45) }
  ']'                 { PT _ (TS _ 46) }
  L_integ             { PT _ (TI $$)   }
  L_quoted            { PT _ (TL $$)   }

%%

Integer :: { Integer }
Integer  : L_integ  { (read (BS.unpack $1)) :: Integer }

String  :: { String }
String   : L_quoted { (BS.unpack $1) }

Contract :: { Language.Marlowe.Syntax.AbsMarlowe.Contract }
Contract
  : 'Close' { Language.Marlowe.Syntax.AbsMarlowe.Close }
  | 'Pay' Party Payee Token Value Contract { Language.Marlowe.Syntax.AbsMarlowe.Pay $2 $3 $4 $5 $6 }
  | 'If' Observation Contract Contract { Language.Marlowe.Syntax.AbsMarlowe.If $2 $3 $4 }
  | 'When' '[' ListCase ']' Timeout Contract { Language.Marlowe.Syntax.AbsMarlowe.When $3 $5 $6 }
  | 'Let' ValueId Value Contract { Language.Marlowe.Syntax.AbsMarlowe.Let $2 $3 $4 }
  | 'Assert' Observation Contract { Language.Marlowe.Syntax.AbsMarlowe.Assert $2 $3 }
  | '(' Contract ')' { $2 }

Case :: { Language.Marlowe.Syntax.AbsMarlowe.Case }
Case
  : 'Case' Action Contract { Language.Marlowe.Syntax.AbsMarlowe.Case $2 $3 }
  | 'MerkleizedCase' Action String { Language.Marlowe.Syntax.AbsMarlowe.MerkleizedCase $2 $3 }

ListCase :: { [Language.Marlowe.Syntax.AbsMarlowe.Case] }
ListCase
  : {- empty -} { [] }
  | Case { (:[]) $1 }
  | Case ',' ListCase { (:) $1 $3 }
  | {- empty -} { [] }
  | Case ListCase { (:) $1 $2 }

Action :: { Language.Marlowe.Syntax.AbsMarlowe.Action }
Action
  : 'Deposit' Party Party Token Value { Language.Marlowe.Syntax.AbsMarlowe.Deposit $2 $3 $4 $5 }
  | 'Choice' ChoiceId '[' ListBound ']' { Language.Marlowe.Syntax.AbsMarlowe.Choice $2 $4 }
  | 'Notify' Observation { Language.Marlowe.Syntax.AbsMarlowe.Notify $2 }
  | '(' Action ')' { $2 }

Value :: { Language.Marlowe.Syntax.AbsMarlowe.Value }
Value
  : 'AvailableMoney' Party Token { Language.Marlowe.Syntax.AbsMarlowe.AvailableMoney $2 $3 }
  | 'Constant' Integer { Language.Marlowe.Syntax.AbsMarlowe.Constant $2 }
  | 'NegValue' Value { Language.Marlowe.Syntax.AbsMarlowe.NegValue $2 }
  | 'AddValue' Value Value { Language.Marlowe.Syntax.AbsMarlowe.AddValue $2 $3 }
  | 'SubValue' Value Value { Language.Marlowe.Syntax.AbsMarlowe.SubValue $2 $3 }
  | 'MulValue' Value Value { Language.Marlowe.Syntax.AbsMarlowe.MulValue $2 $3 }
  | 'DivValue' Value Value { Language.Marlowe.Syntax.AbsMarlowe.DivValue $2 $3 }
  | 'ChoiceValue' ChoiceId { Language.Marlowe.Syntax.AbsMarlowe.ChoiceValue $2 }
  | 'TimeIntervalStart' { Language.Marlowe.Syntax.AbsMarlowe.TimeIntervalStart }
  | 'TimeIntervalEnd' { Language.Marlowe.Syntax.AbsMarlowe.TimeIntervalEnd }
  | 'UseValue' ValueId { Language.Marlowe.Syntax.AbsMarlowe.UseValue $2 }
  | 'Cond' Observation Value Value { Language.Marlowe.Syntax.AbsMarlowe.Cond $2 $3 $4 }
  | '(' Value ')' { $2 }

Observation :: { Language.Marlowe.Syntax.AbsMarlowe.Observation }
Observation
  : 'AndObs' Observation Observation { Language.Marlowe.Syntax.AbsMarlowe.AndObs $2 $3 }
  | 'OrObs' Observation Observation { Language.Marlowe.Syntax.AbsMarlowe.OrObs $2 $3 }
  | 'NotObs' Observation { Language.Marlowe.Syntax.AbsMarlowe.NotObs $2 }
  | 'ChoseSomething' ChoiceId { Language.Marlowe.Syntax.AbsMarlowe.ChoseSomething $2 }
  | 'ValueGE' Value Value { Language.Marlowe.Syntax.AbsMarlowe.ValueGE $2 $3 }
  | 'ValueGT' Value Value { Language.Marlowe.Syntax.AbsMarlowe.ValueGT $2 $3 }
  | 'ValueLT' Value Value { Language.Marlowe.Syntax.AbsMarlowe.ValueLT $2 $3 }
  | 'ValueLE' Value Value { Language.Marlowe.Syntax.AbsMarlowe.ValueLE $2 $3 }
  | 'ValueEQ' Value Value { Language.Marlowe.Syntax.AbsMarlowe.ValueEQ $2 $3 }
  | 'TrueObs' { Language.Marlowe.Syntax.AbsMarlowe.TrueObs }
  | 'FalseObs' { Language.Marlowe.Syntax.AbsMarlowe.FalseObs }
  | '(' Observation ')' { $2 }

Party :: { Language.Marlowe.Syntax.AbsMarlowe.Party }
Party
  : 'Address' String { Language.Marlowe.Syntax.AbsMarlowe.Address $2 }
  | 'Role' String { Language.Marlowe.Syntax.AbsMarlowe.Role $2 }
  | '(' Party ')' { $2 }

Payee :: { Language.Marlowe.Syntax.AbsMarlowe.Payee }
Payee
  : 'Account' Party { Language.Marlowe.Syntax.AbsMarlowe.Account $2 }
  | 'Party' Party { Language.Marlowe.Syntax.AbsMarlowe.Party $2 }
  | '(' Payee ')' { $2 }

Timeout :: { Language.Marlowe.Syntax.AbsMarlowe.Timeout }
Timeout : Integer { Language.Marlowe.Syntax.AbsMarlowe.Timeout $1 }

Bound :: { Language.Marlowe.Syntax.AbsMarlowe.Bound }
Bound
  : 'Bound' Integer Integer { Language.Marlowe.Syntax.AbsMarlowe.Bound $2 $3 }

ListBound :: { [Language.Marlowe.Syntax.AbsMarlowe.Bound] }
ListBound
  : {- empty -} { [] }
  | Bound { (:[]) $1 }
  | Bound ',' ListBound { (:) $1 $3 }
  | {- empty -} { [] }
  | Bound ListBound { (:) $1 $2 }

Token :: { Language.Marlowe.Syntax.AbsMarlowe.Token }
Token
  : 'Token' String String { Language.Marlowe.Syntax.AbsMarlowe.Token $2 $3 }
  | '(' Token ')' { $2 }

ChoiceId :: { Language.Marlowe.Syntax.AbsMarlowe.ChoiceId }
ChoiceId
  : 'ChoiceId' String Party { Language.Marlowe.Syntax.AbsMarlowe.ChoiceId $2 $3 }
  | '(' ChoiceId ')' { $2 }

ValueId :: { Language.Marlowe.Syntax.AbsMarlowe.ValueId }
ValueId : String { Language.Marlowe.Syntax.AbsMarlowe.ValueId $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: BS.ByteString -> [Token]
myLexer = tokens

}

