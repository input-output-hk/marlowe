{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE TupleSections     #-}
{-# LANGUAGE ViewPatterns      #-}

-- | Handles finding imports and compiling them recursively.
-- This is done for each full AST traversal the copmiler does
-- which at this point is InitialPass's preprocessing
-- and Compiler's code generation
module Fay.Compiler.Import
  ( startCompile
  , startCompileText
  , compileWith
  ) where

import           Fay.Compiler.Prelude

import           Fay.Compiler.Misc
import           Fay.Compiler.Parse
import           Fay.Config
import qualified Fay.Exts                        as F
import           Fay.Exts.NoAnnotation           (unAnn)
import           Fay.Types

import           Control.Monad.Except            (throwError)
import           Control.Monad.RWS               (ask, get, gets, lift, listen, modify)
import           Language.Haskell.Exts hiding (name)
import           System.Directory
import           System.FilePath

-- | Start the compilation process using `compileModule` to compile a file.
startCompile :: (FilePath -> String -> Compile a) -> FilePath -> Compile a
startCompile compileModule filein = do
  modify $ \s -> s { stateImported = [] }
  fmap fst . listen $ compileModuleFromFile compileModule filein

startCompileText :: (FilePath -> String -> Compile a) -> FilePath -> String -> Compile a
startCompileText compileModule filein string = do
  modify $ \s -> s { stateImported = [] }
  compileModule filein string

-- | Compile a module
compileWith
  :: Monoid a
  => FilePath
  -> (a -> F.Module -> Compile a)
  -> (FilePath -> String -> Compile a)
  -> (F.X -> F.Module -> IO (Either CompileError F.Module))
  -> String
  -> Compile (a, CompileState, CompileWriter)
compileWith filepath with compileModule before from = do
  rd <- ask
  st <- get
  res <- Compile . lift . lift $
    runCompileModule
      rd
      st
      (parseResult (throwError . uncurry ParseError)
                   (\mod' -> do
                     mod@(Module _ _ _ imports _) <-
                       either throwError return =<< io (before F.noI mod')
                     res <- foldr (<>) mempty <$> mapM (compileImport compileModule) imports
                     modify $ \s -> s { stateModuleName = unAnn $ F.moduleName mod }
                     with res mod
                   )
                   (parseFay filepath from))
  either throwError return res

-- | Compile a module given its file path
compileModuleFromFile
  :: (FilePath -> String -> Compile a)
  -> FilePath
  -> Compile a
compileModuleFromFile compileModule fp = io (readFile fp) >>= compileModule fp

-- | Lookup a module from include directories and compile.
compileModuleFromName
  :: Monoid a
  => (FilePath -> String -> Compile a)
  -> F.ModuleName
  -> Compile a
compileModuleFromName compileModule nm =
  unlessImported nm compileModule
    where
      unlessImported
        :: Monoid a
        => ModuleName l
        -> (FilePath -> String -> Compile a)
        -> Compile a
      unlessImported (ModuleName _ "Fay.Types") _ = return mempty
      unlessImported (unAnn -> name) importIt = do
        imported <- gets stateImported
        case lookup name imported of
          Just _  -> return mempty
          Nothing -> do
            dirs <- configDirectoryIncludePaths <$> config id
            (filepath,contents) <- findImport dirs name
            modify $ \s -> s { stateImported = (name,filepath) : imported }
            importIt filepath contents

-- | Compile an import.
compileImport
  :: Monoid a
  => (FilePath -> String -> Compile a)
  -> F.ImportDecl
  -> Compile a
compileImport compileModule i = case i of
  -- Trickery in fay-base needs this special case
  ImportDecl _ _    _ _ _ (Just "base") _ _ -> return mempty
  ImportDecl _ name _ _ _ _ _ _ -> compileModuleFromName compileModule name

-- | Find an import's filepath and contents from its module name.
findImport :: [FilePath] -> ModuleName a -> Compile (FilePath,String)
findImport alldirs (unAnn -> mname) = go alldirs mname where
  go :: [FilePath] -> ModuleName a -> Compile (FilePath,String)
  go _ (ModuleName _ "Fay.FFI") = return ("Fay/FFI.hs", "module Fay.FFI where\n\ndata Nullable a = Nullable a | Null\n\ndata Defined a = Defined a | Undefined")
  go _ (ModuleName _ "Types") = return ("Fay/Types.hs", "newtype Fay a = Fay (Identity a)\n\nnewtype Identity a = Identity a")
  go _ (ModuleName _ "Data.Data") = return ("Data/Data.hs", "{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE CPP #-}\nmodule Data.Data\n#ifndef FAY\n  (Data,Typeable)\n#endif\n  where\n\nimport \"base\" Data.Data\n") 
  go _ (ModuleName _ "Prelude") = return ("Prelude.hs", "{-# LANGUAGE CPP                  #-}\n{-# LANGUAGE FlexibleInstances    #-}\n{-# LANGUAGE PackageImports       #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n{-# OPTIONS -fno-warn-missing-methods #-}\n\nmodule Prelude\n  (\n  -- Prelude type re-exports\n   Base.Char\n  ,Base.String\n  ,Base.Double\n  ,Base.Int\n  ,Base.Integer\n  ,Base.Bool(..)\n  ,Base.Read\n  ,Base.Show\n  ,Base.Eq\n  ,(==)\n  ,(/=)\n  -- Standard data types\n  ,Maybe(..)\n  ,maybe\n  -- Monads\n  ,(>>=)\n  ,(>>)\n  ,return\n  ,fail\n  ,when\n  ,unless\n  ,forM\n  ,forM_\n  ,mapM\n  ,mapM_\n  ,(=<<)\n  ,sequence\n  ,sequence_\n  ,void\n  ,(>=>)\n  ,(<=<)\n  -- Num\n  ,(*)\n  ,(+)\n  ,(-)\n  -- Ord\n  ,Ord\n  ,Ordering(..)\n  -- An ordering.\n  ,(<)\n  ,(<=)\n  ,(>)\n  ,(>=)\n  ,compare\n  -- Enum\n  ,succ\n  ,pred\n  ,enumFrom\n  ,enumFromTo\n  ,enumFromBy\n  ,enumFromThen\n  ,enumFromByTo\n  ,enumFromThenTo\n  -- Fractional\n  ,(/)\n  -- Integral\n  ,fromIntegral\n  ,fromInteger\n  -- Bools\n  ,(&&)\n  ,(||)\n  ,not\n  ,otherwise\n  -- Show\n  ,show\n  -- Errors\n  ,error\n  ,undefined\n  ,Either(..)\n  ,either\n  -- Functions\n  ,until\n  ,($!)\n  ,seq\n  ,const\n  ,id\n  ,(.)\n  ,($)\n  ,flip\n  ,curry\n  ,uncurry\n  ,snd\n  ,fst\n  -- Numbers\n  ,div\n  ,mod\n  ,divMod\n  ,min\n  ,max\n  ,recip\n  ,negate\n  ,abs\n  ,signum\n  ,pi\n  ,exp\n  ,sqrt\n  ,log\n  ,(**)\n  ,(^^)\n  ,unsafePow\n  ,(^)\n  ,logBase\n  ,sin\n  ,tan\n  ,cos\n  ,asin\n  ,atan\n  ,acos\n  ,sinh\n  ,tanh\n  ,cosh\n  ,asinh\n  ,atanh\n  ,acosh\n  ,properFraction\n  ,truncate\n  ,round\n  ,ceiling\n  ,floor\n  ,subtract\n  ,even\n  ,odd\n  ,gcd\n  ,quot\n  ,quot'\n  ,quotRem\n  ,rem\n  ,rem'\n  ,lcm\n  -- Lists\n  ,find\n  ,filter\n  ,null\n  ,map\n  ,nub\n  ,nub'\n  ,elem\n  ,notElem\n  ,sort\n  ,sortBy\n  ,insertBy\n  ,conc\n  ,concat\n  ,concatMap\n  ,foldr\n  ,foldr1\n  ,foldl\n  ,foldl1\n  ,(++)\n  ,(!!)\n  ,head\n  ,tail\n  ,init\n  ,last\n  ,iterate\n  ,repeat\n  ,replicate\n  ,cycle\n  ,take\n  ,drop\n  ,splitAt\n  ,takeWhile\n  ,dropWhile\n  ,span\n  ,break\n  ,zipWith\n  ,zipWith3\n  ,zip\n  ,zip3\n  ,unzip\n  ,unzip3\n  ,lines\n  ,unlines\n  ,words\n  ,unwords\n  ,and\n  ,or\n  ,any\n  ,all\n  ,intersperse\n  ,prependToAll\n  ,intercalate\n  ,maximum\n  ,minimum\n  ,product\n  ,sum\n  ,scanl\n  ,scanl1\n  ,scanr\n  ,scanr1\n  ,lookup\n  ,length\n  ,length'\n  ,reverse\n  -- IO\n  ,print\n  ,putStrLn\n  ,ifThenElse\n  ,Fay\n  )\n  where\n\n#ifdef FAY\nimport           Data.Data\n#endif\nimport           Fay.FFI\nimport           \"base\" Prelude   (Bool (True, False), Eq, seq, (&&), (/=),\n                                   (==), (||))\nimport qualified \"base\" Prelude   as Base\n#ifndef FAY\nimport           \"base\" Prelude   (Either (..), Maybe (..), Ordering (..))\n#endif\n\n--------------------------------------------------------------------------------\n-- Fixities\n\ninfixr 9  .\ninfixr 8  ^, ^^, **\ninfixl 7  *, /, `quot`, `rem`, `div`, `mod`\ninfixl 6  +, -\n\n-- The (:) operator is built-in syntax, and cannot legally be given\n-- a fixity declaration; but its fixity is given by:\n--   infixr 5  :\n\n-- Provided by base prelude\n--   infix  4  ==, /=\n--   infixr 3  &&\n--   infixr 2  ||\n--   infixr 0  $, $!\n\ninfixr 4  <, <=, >=, >\ninfixl 1  >>, >>=\ninfixr 1  =<<, >=>, <=<\ninfixr 0  $, $!\n\n-- PreludeList\n\ninfixl 9  !!\ninfixr 5  ++\ninfix  4  `elem`, `notElem`\n\n--------------------------------------------------------------------------------\n-- Aliases of base\n\ntype Char    = Base.Char\ntype Double  = Base.Double\ntype Int     = Base.Int\ntype Integer = Base.Integer\ntype String  = Base.String\n\n--------------------------------------------------------------------------------\n-- Standard data types\n\n-- | Maybe type.\n#ifdef FAY\ndata Maybe a = Just a | Nothing\ninstance Base.Read a => Base.Read (Maybe a)\ninstance Base.Show a => Base.Show (Maybe a)\ninstance Typeable a => Typeable (Maybe a)\ninstance Data a => Data (Maybe a)\n#endif\n\n-- | Either type.\n#ifdef FAY\ndata Either a b = Left a | Right b\n#endif\n\nmaybe :: t -> (t1 -> t) -> Maybe t1 -> t\nmaybe m _ Nothing = m\nmaybe _ f (Just x) = f x\n\n--------------------------------------------------------------------------------\n-- Monads\n\n-- | Monomorphic bind for Fay.\n(>>=) :: Ptr (Fay a) -> Ptr (a -> Fay b) -> Ptr (Fay b)\n(>>=) = ffi \"Fay$$_(Fay$$bind(%1)(%2))\"\n\n-- | Monomorphic then for Fay.\n(>>) :: Ptr (Fay a) -> Ptr (Fay b) -> Ptr (Fay b)\n(>>) = ffi \"Fay$$_(Fay$$then(%1)(%2))\"\n\n-- | Monomorphic return for Fay.\nreturn :: a -> Fay a\nreturn = ffi \"Fay$$$_return(%1)\"\n\nfail :: String -> Fay a\nfail = error\n\nwhen :: Bool -> Fay () -> Fay ()\nwhen p m = if p then m else return ()\n\nunless :: Bool -> Fay () -> Fay ()\nunless p m = if p then return () else m\n\nforM :: [a] -> (a -> Fay b) -> Fay [b]\nforM lst fn = sequence $ map fn lst\n\nforM_ :: [a] -> (a -> Fay b) -> Fay ()\nforM_ (x:xs) m = m x >> forM_ xs m\nforM_ []     _ = return ()\n\nmapM :: (a -> Fay b) -> [a] -> Fay [b]\nmapM fn lst = sequence $ map fn lst\n\nmapM_ :: (a -> Fay b) -> [a] -> Fay ()\nmapM_ m (x:xs) = m x >> mapM_ m xs\nmapM_ _ []     = return ()\n\n(=<<) :: (a -> Fay b) -> Fay a -> Fay b\nf =<< x = x >>= f\n\nvoid :: Fay a -> Fay ()\nvoid f = f >> return ()\n\n(>=>) :: (a -> Fay b) -> (b -> Fay c) -> a -> Fay c\n(>=>) f g x = f x >>= g\n\n(<=<) :: (b -> Fay c) -> (a -> Fay b) -> a -> Fay c\n(<=<) g f x = f x >>= g\n\n-- | Evaluate each action in the sequence from left to right,\n-- and collect the results.\nsequence :: [Fay a] -> Fay [a]\nsequence ms = foldr k (return []) ms\n            where\n              k m m' = do { x <- m; xs <- m'; return (x:xs) }\n\nsequence_ :: [Fay a] -> Fay ()\nsequence_ []     = return ()\nsequence_ (m:ms) = m >> sequence_ ms\n\n--------------------------------------------------------------------------------\n-- Num\n\nclass Base.Num a => Num a where\n  (*) :: a -> a -> a\n  (+) :: a -> a -> a\n  (-) :: a -> a -> a\n\ninstance Num Int\ninstance Num Double\n\n--------------------------------------------------------------------------------\n-- Ord\n\n-- An ordering.\n#ifdef FAY\ndata Ordering = GT | LT | EQ\n#endif\n\nclass (Eq a) => Ord a where\n  (<)  :: a -> a -> Bool\n  (<=) :: a -> a -> Bool\n  (>)  :: a -> a -> Bool\n  (>=) :: a -> a -> Bool\n\ninstance Ord Char\ninstance Ord Double\ninstance Ord Int\ninstance Ord Integer\n\ncompare :: Ord a => a -> a -> Ordering\ncompare x y =\n  if x > y\n     then GT\n     else if x < y\n             then LT\n             else EQ\n\n--------------------------------------------------------------------------------\n-- Enum\n\nclass (Base.Enum a) => Enum a where\n\ninstance Enum Int\n-- Integers are represented as JS numbers which aren't arbitrary precision\n-- se we shouldn't add an Enum instance.\n\nsucc :: Num a => a -> a\nsucc x = x + 1\n\npred :: Num a => a -> a\npred x = x - 1\n\nenumFrom :: Num a => a -> [a]\nenumFrom i = i : enumFrom (i + 1)\n\nenumFromTo :: (Ord t, Num t) => t -> t -> [t]\nenumFromTo i n =\n  if i > n then [] else i : enumFromTo (i + 1) n\n\nenumFromBy :: (Num t) => t -> t -> [t]\nenumFromBy fr by = fr : enumFromBy (fr + by) by\n\nenumFromThen :: (Num t) => t -> t -> [t]\nenumFromThen fr th = enumFromBy fr (th - fr)\n\nenumFromByTo :: (Ord t, Num t) => t -> t -> t -> [t]\nenumFromByTo fr by to = if by < 0 then neg fr else pos fr\n  where neg x = if x < to then [] else x : neg (x + by)\n        pos x = if x > to then [] else x : pos (x + by)\n\nenumFromThenTo :: (Ord t, Num t) => t -> t -> t -> [t]\nenumFromThenTo fr th to = enumFromByTo fr (th - fr) to\n\n--------------------------------------------------------------------------------\n-- Fractional\n\nclass (Num a,Base.Fractional a) => Fractional a where\n  (/) :: a -> a -> a\n\ninstance Fractional Double\n\n--------------------------------------------------------------------------------\n-- Integral\n\nclass (Enum a,Base.Integral a) => Integral a\n\ninstance Integral Int\n-- Can't add Integer instance since Integer isn't an Enum (see Enum above).\n\nfromIntegral :: (Num a, Num b) => Ptr a -> Ptr b\nfromIntegral = ffi \"%1\"\n\nfromInteger :: Num a => Ptr Integer -> Ptr a\nfromInteger = ffi \"%1\"\n\n--------------------------------------------------------------------------------\n-- Bools\n\nnot :: Bool -> Bool\nnot p = if p then False else True\n\notherwise :: Bool\notherwise = True\n\n--------------------------------------------------------------------------------\n-- Show\n\n-- | Uses JSON.stringify.\nshow :: Automatic a -> String\nshow = ffi \"JSON.stringify(%1)\"\n\n--------------------------------------------------------------------------------\n-- Errors\n\n-- | Throws a JavaScript error.\nerror :: String -> a\nerror = ffi \"(function() { throw %1 })()\"\n\n-- | Throws \"undefined\" via \"error\".\nundefined :: a\nundefined = error \"Prelude.undefined\"\n\neither :: (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n--------------------------------------------------------------------------------\n-- Functions\n\nuntil :: (a -> Bool) -> (a -> a) -> a -> a\nuntil p f x = if p x then x else until p f (f x)\n\n($!) :: (a -> b) -> a -> b\nf $! x = x `seq` f x\n\nconst :: a -> b -> a\nconst a _ = a\n\nid :: a -> a\nid x = x\n\n(.) :: (t1 -> t) -> (t2 -> t1) -> t2 -> t\n(f . g) x = f (g x)\n\n($) :: (t1 -> t) -> t1 -> t\nf $ x = f x\n\nflip :: (t1 -> t2 -> t) -> t2 -> t1 -> t\nflip f x y = f y x\n\ncurry :: ((a, b) -> c) -> a -> b -> c\ncurry f x y = f (x, y)\n\nuncurry :: (a -> b -> c) -> (a, b) -> c\nuncurry f p = case p of (x, y) -> f x y\n\nsnd :: (t, t1) -> t1\nsnd (_,x) = x\n\nfst :: (t, t1) -> t\nfst (x,_) = x\n\n--------------------------------------------------------------------------------\n-- Numbers\n\ndiv :: Int -> Int -> Int\ndiv x y\n  | x > 0 && y < 0 = quot (x-1) y - 1\n  | x < 0 && y > 0 = quot (x+1) y - 1\ndiv x y            = quot x y\n\nmod :: Int -> Int -> Int\nmod x y\n  | x > 0 && y < 0 = rem (x-1) y + y + 1\n  | x < 0 && y > 0 = rem (x+1) y + y - 1\nmod x y            = rem x y\n\ndivMod :: Int -> Int -> (Int, Int)\ndivMod x y\n  | x > 0 && y < 0 = case (x-1) `quotRem` y of (q,r) -> (q-1, r+y+1)\n  | x < 0 && y > 1 = case (x+1) `quotRem` y of (q,r) -> (q-1, r+y-1)\ndivMod x y         = quotRem x y\n\nmin :: (Num a) => a -> a -> a\nmin = ffi \"Math.min(Fay$$_(%1),Fay$$_(%2))\"\n\nmax :: (Num a) => a -> a -> a\nmax = ffi \"Math.max(Fay$$_(%1),Fay$$_(%2))\"\n\nrecip :: Double -> Double\nrecip x = 1 / x\n\n-- | Implemented in Fay.\nnegate :: Num a => a -> a\nnegate x = (-x)\n\n-- | Implemented in Fay.\nabs :: (Num a, Ord a) => a -> a\nabs x = if x < 0 then negate x else x\n\n-- | Implemented in Fay.\nsignum :: (Num a, Ord a) => a -> a\nsignum x = if x > 0 then 1 else if x == 0 then 0 else -1\n\n-- | Uses Math.PI.\npi :: Double\npi = ffi \"Math.PI\"\n\n-- | Uses Math.exp.\nexp :: Double -> Double\nexp = ffi \"Math.exp(%1)\"\n\n-- | Uses Math.sqrt.\nsqrt :: Double -> Double\nsqrt = ffi \"Math.sqrt(%1)\"\n\n-- | Uses Math.log.\nlog :: Double -> Double\nlog = ffi \"Math.log(%1)\"\n\n-- | Uses Math.pow.\n(**) :: Double -> Double -> Double\n(**) = unsafePow\n\n-- | Uses Math.pow.\n(^^) :: Double -> Int -> Double\n(^^) = unsafePow\n\n-- | Uses Math.pow.\nunsafePow :: (Num a,Num b) => a -> b -> a\nunsafePow = ffi \"Math.pow(Fay$$_(%1),Fay$$_(%2))\"\n\n-- | Implemented in Fay, it's not fast.\n(^) :: Num a => a -> Int -> a\na ^ b | b < 0  = error \"(^): negative exponent\"\n      | b == 0 = 1\n      | even b = let x = a ^ (b `quot` 2) in x * x\na ^ b          = a * a ^ (b - 1)\n\n-- | Implemented in Fay, not fast.\nlogBase :: Double -> Double -> Double\nlogBase b x = log x / log b\n\n-- | Uses Math.sin.\nsin :: Double -> Double\nsin = ffi \"Math.sin(%1)\"\n\n-- | Uses Math.tan.\ntan :: Double -> Double\ntan = ffi \"Math.tan(%1)\"\n\n-- | Uses Math.cos.\ncos :: Double -> Double\ncos = ffi \"Math.cos(%1)\"\n\n-- | Uses Math.asin.\nasin :: Double -> Double\nasin = ffi \"Math.asin(%1)\"\n\n-- | Uses Math.atan.\natan :: Double -> Double\natan = ffi \"Math.atan(%1)\"\n\n-- | Uses Math.acos.\nacos :: Double -> Double\nacos = ffi \"Math.acos(%1)\"\n\n-- | Implemented in Fay, not fast.\nsinh :: Double -> Double\nsinh x = (exp x - exp (-x)) / 2\n\n-- | Implemented in Fay, not fast.\ntanh :: Double -> Double\ntanh x = let a = exp x ; b = exp (-x) in (a - b) / (a + b)\n\n-- | Implemented in Fay, not fast.\ncosh :: Double -> Double\ncosh x = (exp x + exp (-x)) / 2\n\n-- | Implemented in Fay, not fast.\nasinh :: Double -> Double\nasinh x = log (x + sqrt(x**2 + 1))\n\n-- | Implemented in Fay, not fast.\natanh :: Double -> Double\natanh x = log ((1 + x) / (1 - x)) / 2\n\n-- | Implemented in Fay, not fast.\nacosh :: Double -> Double\nacosh x = log (x + sqrt (x**2 - 1))\n\n-- | Implemented in Fay, not fast.\nproperFraction :: Double -> (Int, Double)\nproperFraction x = let a = truncate x in (a, x - fromIntegral a)\n\n-- | Implemented in Fay, not fast.\ntruncate :: Double -> Int\ntruncate x = if x < 0 then ceiling x else floor x\n\n-- | Uses Math.round.\nround :: Double -> Int\nround = ffi \"Math.round(%1)\"\n\n-- | Uses Math.ceil.\nceiling :: Double -> Int\nceiling = ffi \"Math.ceil(%1)\"\n\n-- | Uses Math.floor.\nfloor :: Double -> Int\nfloor = ffi \"Math.floor(%1)\"\n\n-- | Flip (-).\nsubtract :: Num a => a -> a -> a\nsubtract = flip (-)\n\n-- | Implemented in Fay, not fast.\neven :: Int -> Bool\neven x = x `rem` 2 == 0\n\n-- | not (even x)\nodd :: Int -> Bool\nodd x = not (even x)\n\n-- | Implemented in Fay, not fast.\ngcd :: Int -> Int -> Int\ngcd a b = go (abs a) (abs b)\n  where go x 0 = x\n        go x y = go y (x `rem` y)\n\n-- | Uses quot'.\nquot :: Int -> Int -> Int\nquot x y = if y == 0 then error \"Division by zero\" else quot' x y\n\n-- | Uses ~~(a/b).\nquot' :: Int -> Int -> Int\nquot' = ffi \"~~(%1/%2)\"\n\n-- | (quot x y, rem x y)\nquotRem :: Int -> Int -> (Int, Int)\nquotRem x y = (quot x y, rem x y)\n\n-- | Uses rem'.\nrem :: Int -> Int -> Int\nrem x y = if y == 0 then error \"Division by zero\" else rem' x y\n\n-- | Uses %%.\nrem' :: Int -> Int -> Int\nrem' = ffi \"%1 %% %2\"\n\nlcm :: Int -> Int -> Int\nlcm _ 0 = 0\nlcm 0 _ = 0\nlcm a b = abs ((a `quot` (gcd a b)) * b)\n\n--------------------------------------------------------------------------------\n-- Lists\n\nfind :: (a -> Bool) -> [a] -> Maybe a\nfind p (x:xs) = if p x then Just x else find p xs\nfind _ [] = Nothing\n\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter p (x:xs) = if p x then x : filter p xs else filter p xs\nfilter _ []     = []\n\nnull :: [t] -> Bool\nnull [] = True\nnull _ = False\n\nmap :: (a -> b) -> [a] -> [b]\nmap _ []     = []\nmap f (x:xs) = f x : map f xs\n\nnub :: Eq a => [a] -> [a]\nnub ls = nub' ls []\n\nnub' :: Eq a => [a] -> [a] -> [a]\nnub' []     _ = []\nnub' (x:xs) ls =\n  if elem x ls\n     then nub' xs ls\n     else x : nub' xs (x : ls)\n\nelem :: Eq a => a -> [a] -> Bool\nelem x (y:ys)   = x == y || elem x ys\nelem _ []       = False\n\nnotElem :: Eq a => a -> [a] -> Bool\nnotElem x ys = not (elem x ys)\n\nsort :: Ord a => [a] -> [a]\nsort = sortBy compare\n\nsortBy :: (t -> t -> Ordering) -> [t] -> [t]\nsortBy cmp = foldr (insertBy cmp) []\n\ninsertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]\ninsertBy _   x [] = [x]\ninsertBy cmp x ys =\n  case ys of\n    [] -> [x]\n    y:ys' ->\n      case cmp x y of\n         GT -> y : insertBy cmp x ys'\n         _  -> x : ys\n\n-- | Append two lists.\nconc :: [a] -> [a] -> [a]\nconc (x:xs) ys = x : conc xs ys\nconc []     ys = ys\n\nconcat :: [[a]] -> [a]\nconcat = foldr conc []\n\nconcatMap :: (a -> [b]) -> [a] -> [b]\nconcatMap f = foldr ((++) . f) []\n\nfoldr :: (t -> t1 -> t1) -> t1 -> [t] -> t1\nfoldr _ z []     = z\nfoldr f z (x:xs) = f x (foldr f z xs)\n\nfoldr1 :: (a -> a -> a) -> [a] -> a\nfoldr1 _ [x]    = x\nfoldr1 f (x:xs) = f x (foldr1 f xs)\nfoldr1 _ []     = error \"foldr1: empty list\"\n\nfoldl :: (t1 -> t -> t1) -> t1 -> [t] -> t1\nfoldl _ z []     = z\nfoldl f z (x:xs) = foldl f (f z x) xs\n\nfoldl1 :: (a -> a -> a) -> [a] -> a\nfoldl1 f (x:xs) = foldl f x xs\nfoldl1 _ []     = error \"foldl1: empty list\"\n\n(++) :: [a] -> [a] -> [a]\nx ++ y = conc x y\n\n(!!) :: [a] -> Int -> a\na !! b = if b < 0 then error \"(!!): negative index\" else go a b\n  where go []    _ = error \"(!!): index too large\"\n        go (h:_) 0 = h\n        go (_:t) n = go t (n-1)\n\nhead :: [a] -> a\nhead []    = error \"head: empty list\"\nhead (h:_) = h\n\ntail :: [a] -> [a]\ntail []    = error \"tail: empty list\"\ntail (_:t) = t\n\ninit :: [a] -> [a]\ninit []    = error \"init: empty list\"\ninit [_]   = []\ninit (h:t) = h : init t\n\nlast :: [a] -> a\nlast []    = error \"last: empty list\"\nlast [a]   = a\nlast (_:t) = last t\n\niterate :: (a -> a) -> a -> [a]\niterate f x = x : iterate f (f x)\n\nrepeat :: a -> [a]\nrepeat x = x : repeat x\n\nreplicate :: Int -> a -> [a]\nreplicate 0 _ = []\nreplicate n x = if n < 0 then []\n                         else x : replicate (n-1) x\n\ncycle :: [a] -> [a]\ncycle [] = error \"cycle: empty list\"\ncycle xs = xs' where xs' = xs ++ xs'\n\ntake :: Int -> [a] -> [a]\ntake 0 _  = []\ntake _ [] = []\ntake n (x:xs) = if n < 0 then []\n                         else x : take (n-1) xs\n\ndrop :: Int -> [a] -> [a]\ndrop 0 xs = xs\ndrop _ [] = []\ndrop n xss@(_:xs) = if n < 0 then xss\n                             else drop (n-1) xs\n\nsplitAt :: Int -> [a] -> ([a], [a])\nsplitAt 0 xs     = ([], xs)\nsplitAt _ []     = ([], [])\nsplitAt n (x:xs) = if n < 0 then ([],x:xs)\n                            else case splitAt (n-1) xs of (a,b) -> (x:a, b)\n\ntakeWhile :: (a -> Bool) -> [a] -> [a]\ntakeWhile _ []     = []\ntakeWhile p (x:xs) = if p x then x : takeWhile p xs else []\n\ndropWhile :: (a -> Bool) -> [a] -> [a]\ndropWhile _ []     = []\ndropWhile p (x:xs) = if p x then dropWhile p xs else x:xs\n\nspan :: (a -> Bool) -> [a] -> ([a], [a])\nspan _ []     = ([], [])\nspan p (x:xs) = if p x then case span p xs of (a,b) -> (x:a, b) else ([], x:xs)\n\nbreak :: (a -> Bool) -> [a] -> ([a], [a])\nbreak p = span (not . p)\n\nzipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith f (a:as) (b:bs) = f a b : zipWith f as bs\nzipWith _ _      _      = []\n\nzipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]\nzipWith3 f (a:as) (b:bs) (c:cs) = f a b c : zipWith3 f as bs cs\nzipWith3 _ _      _      _      = []\n\nzip :: [a] -> [b] -> [(a,b)]\nzip (a:as) (b:bs) = (a,b) : zip as bs\nzip _      _      = []\n\nzip3 :: [a] -> [b] -> [c] -> [(a, b, c)]\nzip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs\nzip3 _      _      _      = []\n\nunzip :: [(a, b)] -> ([a], [b])\nunzip ((x,y):ps) = case unzip ps of (xs,ys) -> (x:xs, y:ys)\nunzip []         = ([], [])\n\nunzip3 :: [(a, b, c)] -> ([a], [b], [c])\nunzip3 ((x,y,z):ps) = case unzip3 ps of (xs,ys,zs) -> (x:xs, y:ys, z:zs)\nunzip3 []           = ([], [], [])\n\nlines :: String -> [String]\nlines []   = []\nlines s    = case break isLineBreak s of (a, [])   -> [a]\n                                         (a, _:cs) -> a : lines cs\n  where isLineBreak c = c == '\\r' || c == '\\n'\n\nunlines :: [String] -> String\nunlines [] = []\nunlines (l:ls) = l ++ '\\n' : unlines ls\n\nwords :: String -> [String]\nwords str = words' (dropWhile isSpace str)\n  where words' []  = []\n        words' s = case break isSpace s of (a,b) -> a : words b\n        isSpace c  = c `elem` \" \\t\\r\\n\\f\\v\"\n\nunwords :: [String] -> String\nunwords = intercalate \" \"\n\nand :: [Bool] -> Bool\nand []     = True\nand (x:xs) = x && and xs\n\nor :: [Bool] -> Bool\nor []     = False\nor (x:xs) = x || or xs\n\nany :: (a -> Bool) -> [a] -> Bool\nany _ []     = False\nany p (x:xs) = p x || any p xs\n\nall :: (a -> Bool) -> [a] -> Bool\nall _ []     = True\nall p (x:xs) = p x && all p xs\n\nintersperse :: a -> [a] -> [a]\nintersperse _   []      = []\nintersperse sep (x:xs)  = x : prependToAll sep xs\n\nprependToAll :: a -> [a] -> [a]\nprependToAll _   []     = []\nprependToAll sep (x:xs) = sep : x : prependToAll sep xs\n\nintercalate :: [a] -> [[a]] -> [a]\nintercalate xs xss = concat (intersperse xs xss)\n\nmaximum :: (Num a) => [a] -> a\nmaximum [] = error \"maximum: empty list\"\nmaximum xs = foldl1 max xs\n\nminimum :: (Num a) => [a] -> a\nminimum [] = error \"minimum: empty list\"\nminimum xs = foldl1 min xs\n\nproduct :: Num a => [a] -> a\nproduct xs = foldl (*) 1 xs\n\nsum :: Num a => [a] -> a\nsum xs = foldl (+) 0 xs\n\nscanl :: (a -> b -> a) -> a -> [b] -> [a]\nscanl f z l = z : case l of [] -> []\n                            (x:xs) -> scanl f (f z x) xs\n\nscanl1 :: (a -> a -> a) -> [a] -> [a]\nscanl1 _ [] = []\nscanl1 f (x:xs) = scanl f x xs\n\nscanr :: (a -> b -> b) -> b -> [a] -> [b]\nscanr _ z [] = [z]\nscanr f z (x:xs) = case scanr f z xs of (h:t) -> f x h : h : t\n                                        _     -> undefined\n\nscanr1 :: (a -> a -> a) -> [a] -> [a]\nscanr1 _ []     = []\nscanr1 _ [x]    = [x]\nscanr1 f (x:xs) = case scanr1 f xs of (h:t) -> f x h : h : t\n                                      _     -> undefined\n\nlookup :: Eq a1 => a1 -> [(a1, a)] -> Maybe a\nlookup _key []          =  Nothing\nlookup  key ((x,y):xys) =\n  if key == x\n     then Just y\n     else lookup key xys\n\nlength :: [a] -> Int\nlength xs = length' 0 xs\n\nlength' :: Int -> [a] -> Int\nlength' acc (_:xs) = length' (acc+1) xs\nlength' acc _ = acc\n\nreverse :: [a] -> [a]\nreverse (x:xs) = reverse xs ++ [x]\nreverse [] = []\n\n--------------------------------------------------------------------------------\n-- IO\n\nprint :: Automatic a -> Fay ()\nprint = ffi \"(function(x) { if (console && console.log) console.log(x) })(%1)\"\n\nputStrLn :: String -> Fay ()\nputStrLn = ffi \"(function(x) { if (console && console.log) console.log(x) })(%1)\"\n\n--------------------------------------------------------------------------------\n-- Additions\n\n-- | Default definition for using RebindableSyntax.\nifThenElse :: Bool -> t -> t -> t\nifThenElse p a b = if p then a else b\n")
  go _ (ModuleName _ "Marlowe") = return ("Marlowe.hs", "module Marlowe(Value(..), Observation(..), Contract(..), Person, Random, BlockNumber, Cash, ConcreteChoice, Timeout, IdentCC(..), IdentChoice(..), IdentPay(..), prettyPrintContract) where\n\n-- Standard library functions\n\ngroupBy                 :: (a -> a -> Bool) -> [a] -> [[a]]\ngroupBy _  []           =  []\ngroupBy eq (x:xs)       =  (x:ys) : groupBy eq zs\n                           where (ys,zs) = span (eq x) xs\n\n -- People are represented by their public keys,\n -- which in turn are given by integers.\n\ntype Key         = Int   -- Public key\ntype Person      = Key\n\n-- Block numbers and random numbers are both integers.\n \ntype Random      = Int\ntype BlockNumber = Int\n\n-- Observables are things which are recorded on the blockchain.\n--  e.g. \"a random choice\", the value of GBP/BTC exchange rate, \8230\n\n-- Question: how do we implement these things?\n--  - We assume that some mechanism exists which will ensure that the value is looked up and recorded, or \8230\n--  - \8230 we actually provide that mechanism explicitly, e.g. with inter-contract comms or transaction generation or something.\n\n-- Other observables are possible, e.g. the value of the oil price at this time.\n-- It is assumed that these would be provided in some agreed way by an oracle of some sort.\n\n-- The Observable data type represents the different sorts of observables, \8230\n\ndata Observable = Random | BlockNumber\n                    deriving (Eq)\n\nshowObservable Random = \"Random\"\nshowObservable BlockNumber = \"BlockNumber\"\n\n-- Inputs\n-- Types for cash commits, money redeems, and choices.\n--\n-- A cash commitment is an integer (should be positive integer?)\n-- Concrete values are sometimes chosen too: these are integers for the sake of this model.\n\ntype Cash     = Int\ntype ConcreteChoice = Int\n\n-- We need to put timeouts on various operations. These could be some abstract time\n-- domain, but it only really makes sense for these to be block numbers.\n\ntype Timeout = BlockNumber\n\n-- Commitments, choices and payments are all identified by identifiers.\n-- Their types are given here. In a more sophisticated model these would\n-- be generated automatically (and so uniquely); here we simply assume that \n-- they are unique.\n\nnewtype IdentCC = IdentCC Int\n               deriving (Eq)\n\nnewtype IdentChoice = IdentChoice Int\n               deriving (Eq)\n\nnewtype IdentPay = IdentPay Int\n               deriving (Eq)\n\n-- Value is a set of contract primitives that represent constants,\n-- functions, and variables that can be evaluated as an ammount\n-- of money.\n\ndata Value = Committed IdentCC |\n             AddValue Value Value |\n             Value Cash |\n             ValueFromChoice IdentChoice Person Value\n                    deriving (Eq)\n\nshowValue :: Value -> String\nshowValue (Committed (IdentCC icc)) = \"(Committed (IdentCC \" ++ show icc ++ \"))\"\nshowValue (AddValue m1 m2) = \"(AddValue \" ++ showValue m1 ++ \" \" ++ showValue m2 ++ \")\"\nshowValue (Value cash) = \"(Value \" ++ show cash ++ \")\"\nshowValue (ValueFromChoice (IdentChoice ic) p m) = \"(ValueFromChoice (IdentChoice \" ++ show ic ++ \") \" ++ show p ++ \" \" ++ showValue m ++ \")\"\n\n-- Representation of observations over observables and the state.\n-- Rendered into predicates by interpretObs.\n\ndata Observation =  BelowTimeout Timeout | -- are we still on time for something that expires on Timeout?\n                    AndObs Observation Observation |\n                    OrObs Observation Observation |\n                    NotObs Observation |\n                    PersonChoseThis IdentChoice Person ConcreteChoice |\n                    PersonChoseSomething IdentChoice Person |\n                    ValueGE Value Value | -- is first ammount is greater or equal than the second?\n                    TrueObs | FalseObs\n                    deriving (Eq)\n\nshowObservation :: Observation -> String\nshowObservation (BelowTimeout tim) = \"(BelowTimeout \" ++ (show tim) ++ \")\"\nshowObservation (AndObs obs1 obs2) = \"(AndObs \" ++ (showObservation obs1) ++ \" \" ++ (showObservation obs2) ++ \")\"\nshowObservation (OrObs obs1 obs2) = \"(OrObs \" ++ (showObservation obs1) ++ \" \" ++ (showObservation obs2) ++ \")\"\nshowObservation (NotObs obs) = \"(NotObs \" ++ (showObservation obs) ++ \")\"\nshowObservation (PersonChoseThis (IdentChoice ic) per cho) = \"(PersonChoseThis (IdentChoice \" ++ (show ic) ++ \") \" ++ (show per) ++ \" \" ++ (show cho) ++ \")\"\nshowObservation (PersonChoseSomething (IdentChoice ic) per) = \"(PersonChoseSomething (IdentChoice \" ++ (show ic) ++ \") \" ++ (show per) ++ \")\"\nshowObservation (ValueGE m1 m2) = \"(ValueGE \" ++ (showValue m1) ++ \" \" ++ (showValue m2) ++ \")\"\nshowObservation TrueObs = \"TrueObs\"\nshowObservation FalseObs = \"FalseObs\"\n \n-- The type of contracts\n\ndata Contract =\n    Null |\n    CommitCash IdentCC Person Value Timeout Timeout Contract Contract |\n    RedeemCC IdentCC Contract |\n    Pay IdentPay Person Person Value Timeout Contract |\n    Both Contract Contract |\n    Choice Observation Contract Contract |\n    When Observation Timeout Contract Contract\n               deriving (Eq)\n\nshowContract Null = \"Null\"\nshowContract (CommitCash (IdentCC idc) per mon tim1 tim2 con1 con2) = \"(CommitCash (IdentCC \" ++ (show idc) ++ \") \" ++ (show per) ++ \" \" ++ (showValue mon) ++ \" \" ++ (show tim1) ++ \" \" ++ (show tim2) ++ \" \" ++ (showContract con1) ++ \" \" ++ (showContract con2) ++ \")\"\nshowContract (RedeemCC (IdentCC idc) con) = \"(RedeemCC (IdentCC \" ++ (show idc) ++ \") \" ++ (showContract con) ++ \")\"\nshowContract (Pay (IdentPay idp) per1 per2 mon tim con) = \"(Pay (IdentPay \" ++ (show idp) ++ \") \" ++ (show per1) ++ \" \" ++ (show per2) ++ \" \" ++ (showValue mon) ++ \" \" ++ (show tim) ++ \" \" ++ (showContract con) ++ \")\"\nshowContract (Both con1 con2) = \"(Both \" ++ (showContract con1) ++ \" \" ++ (showContract con2) ++ \")\"\nshowContract (Choice obs con1 con2) = \"(Choice \" ++ (showObservation obs) ++ \" \" ++ (showContract con1) ++ \" \" ++ (showContract con2) ++ \")\"\nshowContract (When obs tim con1 con2) = \"(When \" ++ (showObservation obs) ++ \" \" ++ (show tim) ++ \" \" ++ (showContract con1) ++ \" \" ++ (showContract con2) ++ \")\"\n \n\n------------------------\n-- AST dependent code --\n------------------------\n\ndata ASTNode = ASTNodeC Contract\n             | ASTNodeO Observation\n             | ASTNodeM Value\n             | ASTNodeCC IdentCC\n             | ASTNodeIC IdentChoice\n             | ASTNodeIP IdentPay\n             | ASTNodeI Int\n\nlistCurryType :: ASTNode -> (String, [ASTNode])\nlistCurryType (ASTNodeM (Committed identCC))\n = (\"Committed\", [ASTNodeCC identCC])\nlistCurryType (ASTNodeM (AddValue money1 money2))\n = (\"AddValue\", [ASTNodeM money1, ASTNodeM money2])\nlistCurryType (ASTNodeM (Value cash))\n = (\"Value\", [ASTNodeI cash])\nlistCurryType (ASTNodeM\160(ValueFromChoice identChoice\160person\160def))\n = (\"ValueFromChoice\", [ASTNodeIC identChoice, ASTNodeI person, ASTNodeM def])\nlistCurryType (ASTNodeO (BelowTimeout timeout))\n = (\"BelowTimeout\", [ASTNodeI timeout])\nlistCurryType (ASTNodeO (AndObs observation1 observation2))\n = (\"AndObs\", [ASTNodeO observation1, ASTNodeO observation2])\nlistCurryType (ASTNodeO (OrObs observation1 observation2))\n = (\"OrObs\", [ASTNodeO observation1, ASTNodeO observation2])\nlistCurryType (ASTNodeO (NotObs observation))\n = (\"NotObs\", [ASTNodeO observation])\nlistCurryType (ASTNodeO (PersonChoseThis identChoice person concreteChoice))\n = (\"PersonChoseThis\", [ASTNodeIC identChoice, ASTNodeI person, ASTNodeI concreteChoice])\nlistCurryType (ASTNodeO (PersonChoseSomething identChoice person))\n = (\"PersonChoseSomething\", [ASTNodeIC identChoice, ASTNodeI person])\nlistCurryType (ASTNodeO (ValueGE money1 money2))\n = (\"ValueGE\", [ASTNodeM money1, ASTNodeM money2])\nlistCurryType (ASTNodeO TrueObs) = (\"TrueObs\", [])\nlistCurryType (ASTNodeO FalseObs) = (\"FalseObs\", [])\nlistCurryType (ASTNodeC Null) = (\"Null\", [])\nlistCurryType (ASTNodeC (CommitCash identCC person cash timeout1 timeout2 contract1 contract2))\n = (\"CommitCash\", [ASTNodeCC identCC, ASTNodeI person, ASTNodeM cash, ASTNodeI timeout1,\n                   ASTNodeI timeout2, ASTNodeC contract1, ASTNodeC contract2])\nlistCurryType (ASTNodeC (RedeemCC identCC contract))\n = (\"RedeemCC\", [ASTNodeCC identCC, ASTNodeC contract])\nlistCurryType (ASTNodeC (Pay identPay person1 person2 cash timeout contract))\n = (\"Pay\", [ASTNodeIP identPay, ASTNodeI person1, ASTNodeI person2,\n            ASTNodeM cash, ASTNodeI timeout, ASTNodeC contract])\nlistCurryType (ASTNodeC (Both contract1 contract2))\n = (\"Both\", [ASTNodeC contract1, ASTNodeC contract2])\nlistCurryType (ASTNodeC (Choice observation contract1 contract2))\n = (\"Choice\", [ASTNodeO observation, ASTNodeC contract1, ASTNodeC contract2])\nlistCurryType (ASTNodeC (When observation timeout contract1 contract2))\n = (\"When\", [ASTNodeO observation, ASTNodeI timeout, ASTNodeC contract1, ASTNodeC contract2])\nlistCurryType (ASTNodeCC (IdentCC int)) = (\"IdentCC\", [ASTNodeI int])\nlistCurryType (ASTNodeIC (IdentChoice int)) = (\"IdentChoice\", [ASTNodeI int])\nlistCurryType (ASTNodeIP (IdentPay int)) = (\"IdentPay\", [ASTNodeI int])\nlistCurryType (ASTNodeI int) = (show int, [])\n\nisComplex :: ASTNode -> Bool\nisComplex (ASTNodeO _) = True\nisComplex (ASTNodeC _) = True\nisComplex (ASTNodeM _) = True\nisComplex _ = False\n\n--------------------------\n-- AST independent code --\n--------------------------\n\ndata NodeType = Trivial (String, [ASTNode])\n              | Simple (String, [ASTNode])\n              | Complex (String, [ASTNode])\n\ntabulateLine :: Int -> String\ntabulateLine n = replicate n ' '\n\nclassify :: ASTNode -> NodeType\nclassify x\n  | null $ snd r = Trivial r\n  | isComplex x = Complex r\n  | otherwise = Simple r\n  where r = listCurryType x\n\nisTrivial :: NodeType -> Bool\nisTrivial (Trivial _) = True\nisTrivial _ = False\n\nnoneComplex :: NodeType -> NodeType -> Bool\nnoneComplex (Complex _) _ = False\nnoneComplex _ (Complex _)= False\nnoneComplex _ _ = True\n\n-- We assume that Simple nodes have Simple or Trivial children\nsmartPrettyPrint :: Int -> NodeType -> String\nsmartPrettyPrint _ (Trivial a) = prettyPrint 0 a\nsmartPrettyPrint _ (Simple a) = \"(\" ++ prettyPrint 0 a ++ \")\"\nsmartPrettyPrint spaces (Complex a) = \"(\" ++ prettyPrint (spaces + 1) a ++ \")\"\n\nprettyPrint :: Int -> (String, [ASTNode]) -> String\nprettyPrint _ (name, []) = name\nprettyPrint spaces (name, args) = intercalate \"\\n\" (trivialNames : map (tabulateLine newSpaces ++) others)\n  where\n    classified = map classify args\n    newSpaces = spaces + length name + 1\n    groupedClassified = groupBy noneComplex classified\n    trivialNames = unwords (name : map (smartPrettyPrint newSpaces) (head groupedClassified))\n    others = map (unwords . map (smartPrettyPrint newSpaces)) (tail groupedClassified)\n\n-------------\n-- Wrapper --\n-------------\n\nprettyPrintContract :: Contract -> String\nprettyPrintContract = prettyPrint 0 . listCurryType . ASTNodeC\n\n") 
  go (dir:dirs) name = do
    exists <- io (doesFileExist path)
    if exists
           then (path,) . stdlibHack <$> io (readFile path)
           else go dirs name
    where
      path = dir </> replace '.' '/' (prettyPrint name) ++ ".hs"
      stdlibHack = case mname of
                     ModuleName _ "Fay.FFI" -> const "module Fay.FFI where\n\ndata Nullable a = Nullable a | Null\n\ndata Defined a = Defined a | Undefined"
                     _ -> id 
      replace c r = map (\x -> if x == c then r else x)
  go [] name = throwError $ Couldn'tFindImport (unAnn name) alldirs






