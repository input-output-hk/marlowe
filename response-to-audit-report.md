
# DRAFT Response to Audit Report

TODO:

- [ ] Add prefatory text.
- [ ] Add responses and mitigation commits to Isabelle-related findings.
- [ ] Add responses and mitigation commits to Haskell-related findings.
    - [ ] Convert the commit messages to narrative, and just link to the commit.
- [ ] Fix display of equations or replace ones that cannot be fixed with ellipses ("...").
- [ ] Replace broken links and cross references, or use elipses ("...").
- [ ] Verify the section numbering is correct.
- [ ] Add table of contents.
- [ ] Proofread.


## Overview of Isabelle Changes


## Overview of Marlowe-Cardano Specification and Haskell (Plutus) Implementation

TODO: @bwbush will add text here.

```console
commit fca49124f9ebad285bb08d643a3c5fcf5e1df618
Merge: 27a3e32bb 6a0517770
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 15 13:50:51 2023 -0600

    Merge pull request #524 from input-output-hk/PLT-3064
    
    PLT-3064 Cumulative validator changes based on audit report
```


# 2 Findings


## 2.1 Main concerns


### 2.1.1 Negative deposits allow stealing funds *(Severity: High)*

> **File `marlowe-cardano-specification.md`, `Constraint 6`**
>
> The income from deposits is computed by adding up the deposit inputs, regardless of whether they are negative, while the semantics considers them as zero deposits. Combined with the absence of a balance check on the ending Marlowe state, this allows the ending balance to differ from the value paid to the Marlowe validator.
> 
> This disagreement can be exploited to steal money from a flawed Marlowe contract that allows a negative deposit. The issue is demonstrated in ….

TODO: @bwbush will add text here.

```console
commit 15446073131c4098fed781cdcc701b89b77f6bd0
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 16:56:31 2023 -0700

    SCP-5123 Property-based tests for contracts with negative deposits.

commit 4b81ee96b1e7c74c4964cf25f6bb599c80d07a52
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 16:56:31 2023 -0700

    SCP-5123 Property-based tests for contracts with negative deposits.

commit 9d5443c5e9306eaf49ac5389df455e07555c9e04
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 10:54:48 2023 -0700

    SCP-5123 Improved negative-deposit test case.

commit 20bf9f13fe33acf9612ec26fe640d27975b0dc59
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 17:10:11 2023 -0700

    SCP-5123 Rephrased comment.

commit bbb9b8fc21ad93b7bcdb3b60be0f2f9c921f6bec
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 16:56:31 2023 -0700

    SCP-5123 Property-based tests for contracts with negative deposits.

commit 597281c176bcb1f326329ba40b0d968d5e7eb84b
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 11:36:56 2023 -0700

    SCP-5123 Updated validator script size and hash tests.

commit 68791facc195068717cbc6e55d1e4fdbe1f4a521
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 11:20:27 2023 -0700

    SCP-5123 Ensured that negative deposits do not corrupt accounting equation.
```


### 2.1.2 Contracts vulnerable to double satisfaction attacks *(Severity: High)*

> **File `marlowe-cardano-specification.md`, `Constraint 15`**
> 
> No datum is required for outputs fulfilling payments to addresses generated by the evaluation of a Marlowe contract. This implies that these outputs are vulnerable to double satisfaction in transactions involving other contracts that pay to the same wallets. An example is discussed in .
> 
> One way to strengthen the implementation is for the Marlowe validator to demand that outputs paid to addresses contain a datum that identifies the contract instance, like the `TxOutRef` of the validator UTxO being spent. Then cooperation with other contracts is possible without double satisfaction if the validators of the other contracts demand a different datum for their outputs.

TODO: @bwbush will add text here.

```console
commit 0bf75ac775e53507db4e313f705a7a667f98aac1
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Sat Mar 4 09:46:24 2023 -0700

    SCP-5125 Added property-based tests for multiple validators.

commit 9f4fc9cde581b6dbbb939ec9d8e6303b8b67350e
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Fri Mar 3 08:54:31 2023 -0700

    SCP-5141 Property-based tests for duplicate detection in validator.

commit 435ac680eb8119db1c43ec968cf8ea4ef08158b6
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Sat Mar 4 09:46:24 2023 -0700

    SCP-5125 Added property-based tests for multiple validators.

commit 39fcc8aa9d61ed97dfa56e7ce078bf5e4c4cd6cc
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Fri Mar 3 08:54:31 2023 -0700

    SCP-5141 Property-based tests for duplicate detection in validator.

commit 6f6331b463e7f2fddce7ec0f64b37b030f2f795b
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Fri Mar 3 08:54:31 2023 -0700

    SCP-5141 Property-based tests for duplicate detection in validator.

commit 3f222bc363fcf3e9cd2fa0cb5206933ef597a619
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Sat Mar 4 09:46:24 2023 -0700

    SCP-5125 Added property-based tests for multiple validators.

commit 5f673c477ccc9b38626dca505a399962b22c2675
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Sat Mar 4 09:45:32 2023 -0700

    SCP-5125 Included implicit close payments in satisfaction restriction.

commit 4adf115dbf795e4b014eb6ccab0acb20a73e74ed
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Fri Mar 3 13:54:52 2023 -0700

    SCP-5125 Prevented double-satisfaction.
```


### 2.1.3 Missing constructor in equality instance *(Severity: High)*

> **File `Semantics.hs`, Class instance `Eq ReduceWarning`, line *845***
> 
> The constructor `ReduceAssertionFailed` is not mentioned and compares `False` against itself. This might cause validators to fail checking the presence of this particular warning.

TODO: @bwbush will add text here.

```console
commit 04805a393c0815fe0f2a1a6d7f76d9867ffe0c14
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 08:27:25 2023 -0700

    SCP-5129 Hardened `Eq` instances in validator files.
    
    See https://github.com/input-output-hk/marlowe-cardano/pull/513#discussion_r1123062500
    for motivation.

commit 84d65a70c29320fab501ad759bbc71855d1b63fc
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 17:21:39 2023 -0700

    SCP-5129 Fixed `(==)` for `ReduceAssertionFailed`.
```

### 2.1.4 Inaccurate formulation of Money preservation *(Severity: High)*

> **File `specification-v3-rc1.pdf`, Section `3.1 Money preservation`, page *29***
> 
> As the property stands, it is permitted to make deposits in one currency and return payments in a different currency. As long as the sums of the amounts match, the equality is satisfied. Yet it is unlikely that the participants of the contract would agree that money has been preserved.
> 
> Money preservation is a property stated with an equality. The left hand side is the sum of the deposits done by a list of transactions. The right hand side of the equality is the sum of all the payments done in the same list of transactions. Each sum, in turn, is represented as a single integer which aggregates the amounts of the various payments and deposits, irrespective of what currencies correspond to these amounts.


### 2.1.5 Insufficient documentation of Money preservation *(Severity: Medium)*

> **File `specification-v3-rc1.pdf`, Section `3.1 Money preservation`, page *29***
> 
> Money preservation is formulated in terms of functions that are not discussed in the specification. It is necessary to explain the meaning of these functions in sufficient detail so readers can understand the property.


### 2.1.6 Missing description of Merkleization *(Severity: High)*

> **File `specification-v3-rc1.pdf`, `Merkleization`**
> 
> There is no property about merkleization, but merkleization is implemented in the Cardano integration.
> 
> Some relevant properties could be:
> 
> 1.  The merkleized contract produces the same payments as the analogous regular contract.
> 2.  If a merkleized case input is applied successfully, it implies that the contract hash in the input corresponds to the continuation of the contract.
> 3.  Merkleizing and unmerkleizing a contract gives back the original contract.


### 2.1.7 Positive balances are not checked for the output state *(Severity: High)*

> **File `marlowe-cardano-specification.md`, `Constraint 13`** 
> 
> *Positive balances* are only checked for the input, not for the output Marlowe state. If the semantics are flawed, a transaction can produce an unspendable output that does not satisfy this constraint.
> 
> If such a transaction is accepted, no further evaluation will be possible since all subsequent transactions will be rejected due to the very same Constraint 13. This is an hypothetical attack vector, where a malicious actor could send a transaction to block a contract.

TODO: @bwbush will add text here.

```console
commit 8855feae473882b82643db792327423152e45b5c
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 15:27:42 2023 -0700

    SCP-5141 SCP-5142 Enforced initial and final state validity in validator.

commit ebab31d9ba6dd322d374b34cad3995050a0e476e
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 11:52:04 2023 -0700

    SCP-5124 Added property-based test for new final-balance constraint.
```


### 2.1.8 Non-validated Marlowe states *(Severity: High)*

> **File `marlowe-cardano-specification.md`, `Missing constraint`** 
> 
> The validator is not specified to check that the Marlowe states in the input and output datums are valid. This condition is necessary for the lemmas about the Marlowe semantics to be applicable. The Marlowe state could become invalid if there is a flaw in the implementation of the semantics.
> 
> It also could be possible for the Marlowe state to be invalid if someone pays an output to the Marlowe validator with an invalid Marlowe state. Though this problem could be addressed with off-chain checks that prevent sending transactions that spend outputs with invalid Marlowe states. If off-chain checks are used, a note in the specification about how this is handled would be helpful.
> 
> An example showing betrayed user expectations is discussed in .
> 
> For a valid Marlowe state, the association lists for bound values, accounts, and choices have keys sorted and without duplicates.

TODO: @bwbush will add text here.

```console
commit 8855feae473882b82643db792327423152e45b5c
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 15:27:42 2023 -0700

    SCP-5141 SCP-5142 Enforced initial and final state validity in validator.

commit ebab31d9ba6dd322d374b34cad3995050a0e476e
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 11:52:04 2023 -0700

    SCP-5124 Added property-based test for new final-balance constraint.
```


### 2.1.9 Total balance of ending state uncomputed *(Severity: High)*

> **File `marlowe-cardano-specification.md`, `Constraint 6`** 
> 
> The constraint says
> 
> > The beginning balance plus the deposits equals the ending balance plus the payments.
> 
> However, the Marlowe validator never computes the total balance of the accounts in the ending Marlowe state. Instead, the ending balance is assumed to be whatever value is paid by the transaction to the Marlowe validator. The natural language should describe precisely what is being checked.

TODO: @bwbush will add text here.

```console
commit 8855feae473882b82643db792327423152e45b5c
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 15:27:42 2023 -0700

    SCP-5141 SCP-5142 Enforced initial and final state validity in validator.

commit ebab31d9ba6dd322d374b34cad3995050a0e476e
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 11:52:04 2023 -0700

    SCP-5124 Added property-based test for new final-balance constraint.

commit d514bcd075732b07e1c6a73e2e3c68afa01acf2c
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 11:52:04 2023 -0700

    SCP-5124 Added property-based test for new final-balance constraint.

commit 7f562545d013dd17472b692b550ffdc7f8a383f3
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 11:52:04 2023 -0700

    SCP-5124 Added property-based test for new final-balance constraint.
```


### 2.1.10 Unchecked ending balance *(Severity: High)*

> **File `marlowe-cardano-specification.md`, `Constraint 5`** 
> 
> The balance of the starting Marlowe state is checked to match the value in the input. However, the validator does not check that the ending balance matches the value in the output paid to the Marlowe validator. Similarly to Issue [\[main:positive-balances-unchecked\]](#main:positive-balances-unchecked){reference-type="ref" reference="main:positive-balances-unchecked"}, if there are flaws in the semantics that cause the ending balance to differ from the actual value paid to the validator, this constraint would prevent any transaction from spending the output.
> 
> The specification should at least discuss why the check is absent together with the other similar checks that are not implemented (checking that ending accounts have positive balances, checking that the ending Marlowe state is valid).

```console
commit 0a890845c44ccfe4df97e765e9b9eb743ce7d580
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 2 09:32:09 2023 -0700

    SCP-5124 Ensured script output is consistent with output state.

commit 201c5df9de29b3b142be5ff7d0a9b56d1b378204
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 13:35:40 2023 -0700

    PLT-4169 Optimized checking of script output in validator.

commit 26f024e80cea0dd4ebf8bff0f1a10b97aea87894
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Thu Mar 9 12:43:12 2023 -0700

    PLT-3064 Made suggested changes to `examineScripts` in validator.
    
    See https://github.com/input-output-hk/marlowe-cardano/pull/524#discussion_r1127270744.
```


### 2.1.11 Partial functions used outside their domain *(Severity: Medium)*

> **File `MoneyPreservation.thy`, various functions ``**
> 
> `moneyInRefundOneResult`, `moneyInApplyResult`, `moneyInApplyAllResult`, `moneyInTransactionOutput`, and `moneyInPlayTraceResult` have strange meanings when the result is an error. Arguably, on error there is no money to retrieve, so the return type should be `(Token \times int) option` instead.
> 
> Some lemmas rely on this behavior to have equalities hold even in cases of errors, but the cost is that the meaning is so surprising that the reader may be confused by it. It would be more reliable to have explicit and weaker lemmas that assert equalities only when there are no errors.


### 2.1.12 Different insertion functions used in Isabelle and Haskell code *(Severity: High)*

> **File `Semantics.hs`, Several functions ``** 
> 
> Where `MList.insert` is used in the Isabelle semantics, [AssocMap.insert](https://github.com/input-output-hk/plutus/blob/v1.0.0/plutus-tx/src/PlutusTx/AssocMap.hs#L147-L148) is used in the Cardano implementation. However, the functions are not equivalent as demonstrated by the following examples:
> 
> ``` text
> AssocMap.insert 'a' 1 [('b', 0)] == [('b', 0), ('a', 1)]
> -- whereas
> MList.insert 'a' 1 [('b', 0)] == [('a', 1), ('b', 0)]
> ```
> 
> ``` text
> AssocMap.insert 'b' 1 [('a', 0), (‘b’, 0), (‘b’, 0)] == [('a', 0), ('b', 1), (‘b’, 1)]
> -- whereas
> MList.insert 'b' 1 [(‘a’, 0), ('b', 0), ('b', 0)] == [('a', 0), ('b', 1), ('b', 0)]
> ```
> 
> This renders the Isabelle lemmas inapplicable for the Cardano integration. The lemmas need to demand some properties of an `insert` function without fully spelling it out, or the Cardano integration needs to use `MList.insert` instead of `AssocMap.insert`.
> 
> Similarly, functions `AssocMap.delete` and `MList.delete` differ in behavior when the input map is not sorted:
> 
> ``` text
> AssocMap.delete 'a' [(‘b’, 0), (‘a’, 0)] == [('b', 0)]
> -- whereas
> MList.delete 'a' [(‘b’, 0), ('a', 0)] == [('b', 0), ('a', 0)]
> ```
> 
> Functions `AssocMap.lookup` and `MList.lookup` also differ in behavior when the input map is not sorted:
> 
> ``` text
> AssocMap.lookup 'a' [(‘b’, 0), (‘a’, 0)] == Just 0
> -- whereas
> MList.lookup 'a' [(‘b’, 0), ('a', 0)] == Nothing
> ```
> 
> The following usage places were found:
> -   Line 395, `evalValue` depends on `moneyInAccount` which depends on `AssocMap.lookup`.
> -   Line 413, `evalValue` depends on `AssocMap.lookup`.
> -   Line 428, `evalObservation` depends on `AssocMap.member`.
> -   Line 456, function `updateMoneyInAccount` relies on `AssocMap.delete` and `AssocMap.insert`.
> -   Line 482, function `reduceContractStep` relies on `AssocMap.insert`.
> -   Line 567, function `applyAction` relies on `AssocMap.insert`.

TODO: @bwbush will add text here.

```console
commit 9e068b6a60103f2a40604a7eaea57c5f29b59180
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 11:00:45 2023 -0700

    SCP-5126 Aligned `Gen MList` with semantics.

commit b65ccfec3708484ff52514671e0e227c13f084f3
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 10:52:17 2023 -0700

    SCP-5126 Hardened equivalence testing for `MList` vs `AssocMap`.

commit a95a616aca59bc7159d3ffa92487f8f021820bff
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 10:28:54 2023 -0700

    SCP-5126 Elaborated comments on `MList` property tests.

commit e2277677987f359dcd8754275eccd5b7c9a880a7
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 10:23:16 2023 -0700

    SCP-5126 Added note on invariants in unpack and repacking `AssocMap`.

commit af380a292c0369bcc77d8584d81ea80a31326b61
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Feb 28 13:49:44 2023 -0700

    SCP-5126 Property-based tests for `MList` vs `AssocMap`.

commit a2ff6aa334efb7b7955408d29cf0e2edf06bca08
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Feb 28 12:05:32 2023 -0700

    SCP-5126 Annotated Marlowe validator regarding association lists.
```


### 2.1.13 Missing specification tests *(Severity: Medium)*

> **File `Spec/Marlowe/Semantics/Compute.hs`, ``** 
> 
> There are no tests for the properties in Section 3 of `specification-v3-rc1.pdf`. Besides checking that there are no translation mistakes, these properties would also help contrasting the assumptions in the Isabelle and the Haskell sides, like the meaning of validity of an association list, which is focused in the previous issue.

TODO: @bwbush will add text here.


## 2.2 Marlowe specification


### 2.2.1 Lack of explanation regarding changing choices *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.1.4 Choices`, page *10***
> 
> Choices can only be changed when evaluating `When` statements. This is something only evident after looking at the implementation of `computeTransaction`. It needs to be discussed when first introducing choices and the `When` contract.


### 2.2.2 Undefined reference *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.1.7 Contracts`, page *13***
> 
> There is an undefined reference.


### 2.2.3 Lack of explanation for necessity of `Environment` type *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.1.8 State and Environment`, page *14***
> 
> An `Environment` type is introduced, but it is unclear why it is needed as it is defined as a synonym for time intervals.


### 2.2.4 Unclear meaning of execution environment *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.1.8 State and Environment`, page *14***
> 
> The meaning of the execution environment of the transaction is unclear. This is due to the concept of *transaction* being assumed by the specification and never formally introduced.
> 
> The specification reads
> 
> > The execution environment of a Marlowe contract simply consists of the (inclusive) time interval within which the transaction is occurring.
> 
> One has to infer that evaluating a Marlowe contract is undefined if it does not happen within a transaction, as otherwise the description of the execution environment would not make sense. It would be necessary to establish more explicitly the relationship between the contract evaluation and the notion of transaction.


### 2.2.5 Unexplained interval data types *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.1.8 State and Environment`, page *14***
> 
> The meaning of the data types `IntervalError` and `IntervalResult` needs to be explained.


### 2.2.6 Incomplete explanation for `TransactionOutput` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.1 Compute Transaction`, page *15***
> 
> The meaning of the data type `TransactionOutput` needs to be explained. More generally, the meaning of the return types of most functions has to be explained. Currently, the meaning can only be inferred from looking at how the types are used, which makes it harder to identify if they are used as intended.
> 
> The purpose of these types needs to be made explicit so it can be checked if the code is doing what is intended.


### 2.2.7 Code snippets switch languages *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.1 Compute Transaction`, page *15***
> 
> The specification changes from using Isabelle to using Haskell henceforth. Making the reader aware of the criteria for the language change would help maintaining the document.


### 2.2.8 Repeated definition of `IntervalResult` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Sections `2.1.8 State and Environment, 2.2.2 Fix Interval`, pages *14, 16***
> 
> The `IntervalResult` type is defined twice in the specification. One should be removed.


### 2.2.9 Poorly named variable `newAccount` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.6 Reduce Contract Step`, page *19***
> 
> In the implementation of the function `reduceContractStep`, the variable `newAccount` should be named `newAccounts`.


### 2.2.10 Poorly named variable `acc` in specification *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.8 Apply Cases`, page *22***
> 
> On the last equation of `applyCases`, `acc` should be named `input`.


### 2.2.11 Inaccurate specification of `giveMoney` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.9 Utilities`, page *22***
> 
> It says
> 
> > The *giveMoney* function transfers funds internally between accounts.
> 
> which is not accurate. It should say instead
> 
> > The *giveMoney* function deposits funds to an internal account.
> 
> This function is confusing in that it takes the account identifier of the paying account which is not used for anything other than filling a field in the returned value.


### 2.2.12 Redundant evaluation in `addMoneyToAccount` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.9 Utilities`, page *22***
> 
> `addMoneyToAccount` is redundantly evaluating `money <= 0` when invoking `updateMoneyInAccount`. The else branch could be replaced instead with `insert (accId, token) money accountsV`.


### 2.2.13 Redundant statement regarding addition *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.10 Evaluate Value`, page *24***
> 
> It says that addition is associative and commutative. This is true but it is already implied by the equation preceding the statement. Maybe change to
> 
> > Note that addition is associative and commutative.
> 
> or remove the redundant statement.


### 2.2.14 Missing implementation for negation case of `evalValue` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.10 Evaluate Value`, page *24***
> 
> Negation for `evalValue` does not show the implementation, just one lemma about `NegValue`, which is inconsistent with how other operations are presented.


### 2.2.15 Missing parentheses in `div` specification *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.10 Evaluate Value`, page *25***
> 
> On page 25 formula $$c \neq 0 \Rightarrow c \mathbin{∗} a \mathbin{\mathrm{div}} (c \mathbin{∗} b) = a \mathbin{\mathrm{div}} b$$ needs additional parentheses around the term $c \mathbin{∗} a$, otherwise it can be parsed as $$c \neq 0 \Rightarrow c \mathbin{∗} (a \mathbin{\mathrm{div}} (c \mathbin{∗} b)) = a \mathbin{\mathrm{div}} b$$ which does not hold (Counter-example: $c=2, a=3, b=2$). The lemma `divMultiply` in the file `Semantics.thy` does use extra parentheses around $c \mathbin{∗} a$.


### 2.2.16 Unclear division explanation *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.10 Evaluate Value`, page *25***
> 
> It says
> 
> > Division is a special case because we only evaluate to natural numbers.
> 
> The meaning of this statement needs to be further explained, since the arguments of `DivValue` could evaluate to negative numbers.


### 2.2.17 Discrepancy with `evalValue` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.10 Evaluate Value`, pages *23--26***
> 
> The order of some cases for `evalValue` is different in the specification text and in the actual Isabelle code, and several cases (for example, `NegValue`) are missing from the specification entirely.
> 
> Moreover, the definition of `evalValue` is juxtaposed with some lemmas about its behavior (for example, `AddValue` being associative and commutative), making it harder to match the specification text with the Isabelle code.


### 2.2.18 Missing `evalValue` lemmas in specification *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.10 Evaluate Value`, pages *23--26***
> 
> Not all lemmas about `evalValue` are listed in the specification. The absent lemmas include `evalDoubleNegValue`, `evalMulValue`, `evalSubValue`, and all division lemmas.


### 2.2.19 Typo in **Use Value** case of `evalValue` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2.2.10 Evaluate Value`, page *26***
> 
> The **Use Value** case mentions `TimeIntervalEnd` instead of `UseValue`.


### 2.2.20 Unexplained parameters of `playTrace` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `3 Marlowe Guarantees`, page *28***
> 
> The parameters of the function `playTrace` need to be explained.


### 2.2.21 Type parameter discrepancy in `playTrace` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `3 Marlowe Guarantees`, page *28***
> 
> The first parameter of `playTrace` in the specification is `int`, while it is `POSIXTime` in the code. Even though the latter is an alias for the former, it is beneficial to use the `POSIXTime` name both for consistency and readability.


### 2.2.22 Money preservation on failing transactions not specified *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `3.1 Money preservation`, page *29***
> 
> Money preservation is expressed with an equality. This equality, however, only ensures money preservation for those lists of transactions that produce no error. In other words, there is no guarantee that money will be preserved for those lists of transactions that fail.
> 
> This is not a concern in practice because the lists of transactions that fail to evaluate are not accepted in the blockchain. However, this should be made explicit in the explanation of the property.


### 2.2.23 Complicated definition of `allAccountsPositive` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `3.3 Possitive Accounts`, page *30***
> 
> The definition of\ `allAccountsPositive` is complicated and can be refactored as `all ((_, money) -> money > 0)`.


### 2.2.24 Discrepancy with Isabelle code for `allAccountsPositive` *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Sections `3.3 Positive Accounts`, page *30***
> 
> The `allAccountsPositive` function is defined differently in the specification and in the Isabelle code, although both definitions show the same behavior. These definitions need to be consolidated.


### 2.2.25 Misleading or incorrect formula for contract not holding funds *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `3.6.3 Contract Does Not Hold Funds After it Closes`, page *32***
> 
> The statement in natural language looks unconnected from the proposed formula. Otherwise, it is unclear how not holding funds forever is a consequence of producing no warnings.


### 2.2.26 Different format for lemma statement *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Sections `3.6.2 All Contracts Have a Maximum Time`, page *32***
> 
> The lemma is stated using the proof derivation tree format as opposed to the rest of the specification and the Isabelle code.


### 2.2.27 Function `isClosedAndEmpty` is unexplained *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `3.6.2 All Contracts Have a Maximum Time`, page *32***
> 
> The function `isClosedAndEmpty` needs to be explained.


### 2.2.28 Top-down definitions *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Section `2`** 
> 
> In Section 2, the order of definitions is reversed, and the reader is thus faced with functions which call other functions that have not been introduced yet, despite the claim in Section 1.3 that the definitions will be presented bottom-up.


### 2.2.29 No mention of Isabelle lemmas in specification *(Severity: Low)*

> **File `specification-v3-rc1.pdf`, Multiple sections ``** 
> 
> Generally, readability can be improved by mentioning the Isabelle lemma names alongside their statements. This way, it would be much easier to search for the actual Isabelle code and proofs matching the informal specification text, and compare the two.


## 2.3 Lemmas and proofs


### 2.3.1 Unnecessarily large proofs *(Severity: Medium)*

> **Several Isabelle files, several lemmas**
> 
> Some Isabelle proofs are written with long apply-scripts, where Isar would document the proof better. Proofs could also be split using more auxiliary lemmas.
> 
> As the proofs stand, it is hard to figure out why a proof step fails, after changes elsewhere required a proof to be updated. Since the newly-failing proof step was designed with specific goals in mind, and changes in the code may lead to it facing a different set of goals, the maintainer might need to reconstruct the whole structure of the proof from an older version to infer state that Isabelle produces at each step.
> 
> What Isar brings is making the intention of the author explicit at every step of the proof. This helps the maintainer of the proofs and fixes the concerns mentioned above.
> 
>  will likely have to update the proofs. We conjecture that it will happen at least every time they target a new platform. In the case of Cardano, they need to extend the semantics to explain Merkleization. Another action that would make long proofs easier to understand is to split them using more auxiliary lemmas, thus feeding the information to the reader in smaller chunks.
> 
> Some examples of large proofs:
> -   in `MoneyPreservation.thy`, lemmas `reduceContractStep_preserves_money` and\ `reductionLoop_preserves_money`
> -   in `SingleInputTransactions.thy`, lemmas `applyAllInputsPrefix_aux`,\ `computeTransactionIterative`, and `computeTransactionStepEquivalence_error`


### 2.3.2 Long lines in lemmas *(Severity: Low)*

> **Several Isabelle files, several lemmas**
> 
> Lines are sometimes long which makes it difficult to understand the lemmas. Lemmas need to be formulated expressing one hypothesis per line and the conclusion on a separate line. Complex hypotheses need to be indented using several lines to expose their structure.
> 
> Besides the effort of scrolling the text horizontally, the hypotheses are hard to separate visually, and so is the conclusion. Furthermore, when a hypothesis is a nested implication it is difficult to see where it ends without further indentation.
> 
> Some examples of lemmas with long lines or non-trivial hypothesis follow.
> -   in `CloseSafe.thy`, lemmas `closeIsSafe_reduceContractUntilQuiescent`, and `closeIsSafe_reductionLoop`
> -   in `MoneyPreservation.thy`, lemmas `reductionLoop_preserves_money_Payment_not_ReduceNoWarning`, `reductionLoop_preserves_money_Payment` and `reduceContractStep_preserves_money_acc_to_party`
> -   in `SingleInputTransactions.thy`, lemma `applyAllLoop_longer_doesnt_grow`
> -   in `TimeRange.thy`, lemmas `reduceStep_ifCaseLtCt` and `reduceLoop_ifCaseLtCt`
> -   in `ValidState.thy`, lemma `reductionLoop_preserves_valid_state_aux`


### 2.3.3 Confusing auxiliary lemmas *(Severity: Low)*

> **Several Isabelle files, several lemmas**
> 
> Some Isabelle proofs resort to declaring auxiliary lemmas with names suffixed with *\_aux*. Sometimes these lemmas are not expressed succinctly, and look more like a punctual copy of the state of some particular proof that is later developed. For the sake of maintaining the proofs, it would be necessary to structure them in a way that presents the information piecewise to the reader. More generally, even auxiliary lemmas should have a well-defined meaning.
> 
> We found this problem at least in the following:
> -   in `QuiescentResult.thy`, lemmas `reduceContractStepPayIsQuiescent`, `reductionLoopIsQuiescent_aux`, and `applyAllInputsLoopIsQuiescent_loop`
> -   in `PositiveAccounts.thy`, lemma `positiveMoneyInAccountOrNoAccountImpliesAllPositive_aux2`
> -   in `SingleInputTransactions.thy`, lemma `applyAllInputsPrefix_aux`


### 2.3.4 Undescriptive variable names *(Severity: Low)*

> **Several Isabelle files, several lemmas**
> 
> Many Isabelle proof statements and proofs use uninformative variable names. The most common example occurs with variables named $\mathit{x11}, \mathit{x12}$, etc. These inhibit the reader from easily understanding the lemma statements, and often require looking back at constructors to understand what these variables represent.
> 
> Some examples of lemmas with these uninformative variable names follow:
> -   in `QuiescentResult.thy`, lemma `reductionLoopIsQuiescent_aux`
> -   in `SingleInputTransactions.thy`, lemmas `beforeApplyAllLoopIsUseless` and\ `applyAllInputsPrefix_aux`
> -   in `ValidState.thy`, lemma `reductionLoop_preserves_valid_state_aux`
> -   in `TimeRange.thy`, lemmas `resultOfReduceIsCompatibleToo`, `resultOfReductionLoopIsCompatibleToo`, `resultOfReduceUntilQuiescentIsCompatibleToo`, `reduceLoop_ifCaseLtCt`, and\ `reduceContractUntilQuiescent_ifCaseLtCt`


### 2.3.5 Involved proof of `insert_valid` *(Severity: Low)*

> **File `MList.thy`, theorem `insert_valid`, line *66***
> 
> The proof of `insert_valid` sprouts three other lemmas of difficult characterization: `insert_valid_aux`, `insert_valid_aux2`, and `insert_valid_aux3`. These lemmas make assumptions with implications that get in the way of understanding them in isolation.
> 
> An alternative to make the proof pieces more reusable is to use instead the following set of lemmas, which also offers insight on how function `insert` interacts with predicates `sorted` and `distinct`:
> 
> ``` {.text escapeinside="||" mathescape="true"}
>   lemma insert_set:
>     "set (map fst (insert a b xs)) = set (map fst xs) |$\cup$| { a }"
> 
>   lemma insert_sorted:
>     "List.sorted (map fst c) |$\Longrightarrow$| List.sorted (map fst (insert a b c))"
> 
>   lemma insert_distinct :
>     "List.distinct (map fst c)
>      |$\Longrightarrow$|
>      List.sorted (map fst c)
>      |$\Longrightarrow$|
>      List.distinct (map fst (MList.insert a b c))"
> ```
> 
> which then can be combined in the proof of `insert_valid` as follows:
> 
> ``` {.text escapeinside="||" mathescape="true"}
>   theorem insert_valid2 : "valid_map c |$\Longrightarrow$| valid_map (MList.insert a b c)"
>     using insert_sorted[of c a b] insert_distinct[of c a b] by fastforce
> ```
> 
> The proofs of the lemmas can be found in .


### 2.3.6 Repeated verbose expression *(Severity: Low)*

> **File `MoneyPreservation.thy`, lemma `removeMoneyFromAccount_preservation`, line *202***
> 
> The expression
> 
> ``` text
>   giveMoney
>     accId
>     (Party p)
>     tok
>     paidMoney
>     (updateMoneyInAccount accId tok (balance - paidMoney) accs)
> ```
> 
> is large and used in other lemmas as well. It would need to be moved to a separate function to save the effort of reading it repeteadly.


### 2.3.7 Inconsistent variable name `valTrans` *(Severity: Low)*

> **File `MoneyPreservation.thy`, lemma `transferMoneyBetweenAccounts_preserves_aux`, line *257***
> 
> The lemma uses a variable `valTrans` where other proofs use the name `paidMoney`. To convey the meaning of the variable faster, the same name should be used consistently in all places.


### 2.3.8 Unused binding `interAccs` *(Severity: Low)*

> **File `MoneyPreservation.thy`, lemma `transferMoneyBetweenAccounts_preserves_aux`, line *263***
> 
> The binding `interAccs` was probably intended to be used on this line. It should either be used or removed from the premise.


### 2.3.9 Undescriptive variable name `acc` *(Severity: Low)*

> **File `MoneyPreservation.thy`, lemma `transferMoneyBetweenAccounts_preserves`, line *295***
> 
> This lemma has a variable `acc` that is used together with `tok2`. It would be more descriptive to call it `accId2`.


### 2.3.10 Misleading indentation *(Severity: Low)*

> **File `MoneyPreservation.thy`, lemmas `reductionLoop_preserves_money_NoPayment_not_ReduceNoWarning, reductionLoop_preserves_money_NoPayment`, lines *430, 439***
> 
> The indentation is misleading: the premises on these lines are indented as if they are a part of the previous functional premise.


### 2.3.11 Missing theorem regarding `playTrace` *(Severity: Low)*

> **File `PositiveAccounts.thy`, `playTrace preserves valid and positive state`** 
> 
> There is no theorem that `playTrace` keeps the state valid and positive when given a state which is valid and positive. This trivially follows from `playTraceAux_preserves_validAndPositive_state` but no such theorem is present.


### 2.3.12 Unconcise goal in `reduceContractStepPayIsQuiescent` *(Severity: Low)*

> **File `QuiescentResult.thy`, lemma `reduceContractStepPayIsQuiescent`, line *8***
> 
> This lemma does not express its goal concisely, as it makes no mention of `reduceContractStep` in the formulation. Changing the first assumption to $\texttt{reduceContractStep}\ \mathit{env}\ \mathit{sta}\ (\texttt{Pay}\ \mathit{x21}\ \mathit{x22}\ \mathit{tok}\ \mathit{x23}\ \mathit{x24})$ makes more explicit in which contexts this lemma can be useful. Modifying this assumption requires an additional `apply simp` to be added to the proof (before line 30) for the lemma to go through. Further, an additional `apply simp` will need to be added in lemmas `reduceContractStepIsQuiescent` (before line 44) and `timedOutReduce_only_quiescent_in_close` (`Timeout.thy`, before line 128) as well.


### 2.3.13 Misleading lemma names *(Severity: Low)*

> **File `PositiveAccounts.thy`, lemma `reduceOne_gtZero`, line *80***
> 
> This lemma should be renamed as `refundOne_gtZero`.
> 
> **File `QuiescentResult.thy`, lemma `reduceOneIsSomeIfNotEmptyAndPositive`, line *32***
> 
> This lemma should be renamed as `refundOneIsSomeIfNotEmptyAndPositive`.
> 
> **File `TransactionBound.thy`, lemma `computeTransaction_decreases_maxTransaction_aux`, line *240***
> 
> This lemma should be renamed as `applyAllInputs_decreases_maxTransactions` or `applyAllInputs_reduced_decreases_maxTransactions`.


### 2.3.14 Misleading variable name `reduced` *(Severity: Low)*

> **File `QuiescentResult.thy`, lemmas `reductionLoop_reduce_monotonic, reduceContractUntilQuiescent_ifDifferentReduced`, lines *138, 153***
> 
> The boolean variable name `reduce` would be better named `reduced` as it is signifying that the contract has been reduced.


### 2.3.15 Undescriptive name `beforeApplyAllLoopIsUseless` *(Severity: Low)*

> **File `SingleInputTransactions.thy`, lemma `beforeApplyAllLoopIsUseless`, line *270***
> 
> This lemma seems to say that `reduceContractUntilQuiescent` has no effect when composed with `applyAllLoop`, because `applyAllLoop` evaluates `reduceContractUntilQuiescent`, and `reduceContractUntilQuiescent` is idempotent.
> 
> A more descriptive name for this lemma could be `reduceContractUntilQuiescent_hasNoEffect_before_applyAllLoop`


### 2.3.16 Unused and undocumented lemmas *(Severity: Low)*

> **Several Isabelle files, several lemmas**
> 
> Some lemmas are never used, and they would need comments motivating their presence:
> 1.  In file `MoneyPreservation.thy`, line 257, lemma `transferMoneyBetweenAccounts_preserves_aux`.
> 2.  In file `QuiescentResult.thy`
>     1.  Line 5, lemma `reduceOne_onlyIfNonEmptyState`
>     2.  Line 153, lemma `reduceContractUntilQuiescent_ifDifferentReduced`
> 3.  In file `PositiveAccounts.thy`, line 66, lemma `positiveMoneyInAccountOrNoAccount_sublist_gtZero`. Furthermore, it is identical to `positiveMoneyInAccountOrNoAccount_gtZero_preservation`, but with an additional assumption `money > 0`.
> 4.  In file `ValidState.thy`
>     1.  Line 9, lemma `valid_state_valid_choices`
>     2.  Line 13, lemma `valid_state_valid_valueBounds`
> 5.  In file `SingleInputTransactions.thy`, line 1214, lemma `traceListToSingleInput_isSingleInput`. It is mentioned in a commented out line in `StaticAnalysis.thy`. Furthermore, the lemma can be expressed more concisely as $$\llparenthesis \mathit{interval} = \mathit{inte}, \mathit{inputs} = \mathit{inp\_h}\ \#\ \mathit{inp\_t} \rrparenthesis\ \#\ t = \mathit{traceListToSingleInput}\ \mathit{t2} % \mathrel{% \mbox{\fontfamily{cmr}\fontencoding{OT1}\selectfont=}}% \joinrel\Rightarrow\mathit{inp\_t} = []$$


### 2.3.17 Redundant `reduceContractStep` lemmas *(Severity: Low)*

> **File `MoneyPreservation.thy`, lemma `reduceContractStep_preserves_money_acc_to_acc_aux`, line *310***
> 
> This lemma is weaker than `transferMoneyBetweenAccounts_preserves`. If we replace its usage at line 351 with `transferMoneyBetweenAccounts_preserves`, the proof goes through.


### 2.3.18 Redundant `transferMoneyBetweenAccounts_preserves` *(Severity: Low)*

> **File `MoneyPreservation.thy`, lemma `reduceContractStep_preserves_money_acc_to_acc`, line *332***
> 
> This lemma is weaker than `transferMoneyBetweenAccounts_preserves`. We can replace its usage site in line 376
> 
> ``` text
>   using
>     reduceContractStep_preserves_money_acc_to_acc
>     validAndPositive_state.simps
>    by blast
> ```
> 
> with
> 
> ``` text
>   using transferMoneyBetweenAccounts_preserves validAndPositive_state.simps by auto
> ```


### 2.3.19 Duplicated lemmas *(Severity: Low)*

> **File `PositiveAccounts.thy`, theorems `computeTransaction_gtZero, accountsArePositive`, lines *257, 369***
> 
> These theorems are identical (modulo variable names), and one of them should be removed.
> 
> **File `PositiveAccounts.thy, ValidState.thy`, lemma `valid_state_valid_accounts`, lines *381, 5***
> 
> This lemma is defined twice, once in each of these files. One of them should be removed.


### 2.3.20 Redundant `computeTransaction` lemmas *(Severity: Low)*

> **File `ValidState.thy`, lemmas `computeTransaction_preserves_valid_state_aux, computeTransaction_preserve_valid_state`, lines *160, 176***
> 
> If `computeTransaction_preserves_valid_state_aux` is rewritten to have the same formulation as `computeTransaction_preserves_valid_state`, then the lemma (with the exact same proof) is still accepted, and these lemmas become duplicates of each other. Thus, no auxiliary lemma is needed.


### 2.3.21 Complicated formulation of `updateMoneyInAccount_money2_aux` *(Severity: Low)*

> **File `MoneyPreservation.thy`, lemma `updateMoneyInAccount_money2_aux`, line *159***
> 
> `updateMoneyInAccount_money2_aux` could be expressed simpler by removing the hypothesis `moneyToPay >= 0`, leaving
> 
> ``` {.text escapeinside="||" mathescape="true"}
>   valid_map (((thisAccId, tok), money) # tail) |$\Longrightarrow$|
>   allAccountsPositive (((thisAccId, tok), money) # tail) |$\Longrightarrow$|
>   moneyInAccount thisAccId tok (((thisAccId, tok), money) # tail) > 0"
> ```
> 
> The proof of `updateMoneyInAccount_money2` can then in turn be trivially adjusted so it still works, by changing the step cases
> 
> ``` {.text escapeinside="||" mathescape="true"}
>   cases "moneyInAccount accId tok ((thisAccIdTok, money) # tail) + moneyToPay |$\leq$| 0"
> ```
> 
> to
> 
> ``` {.text escapeinside="||" mathescape="true"}
>   cases "moneyInAccount accId tok ((thisAccIdTok, money) # tail) |$\leq$| 0"
> ```


### 2.3.22 Complicated proofs that can be simplified *(Severity: Low)*

> **File `MoneyPreservation.thy`, lemma `moneyInInput_is_positive`, line *53***
> 
> The proof could be more general with `apply (cases x; simp)` instead of using `metis`.
> 
> **File `MoneyPreservation.thy`, lemma `reductionLoop_preserves_money_NoPayment_not_ReduceNoWarning`, line *434***
> 
> This lemma can be proved directly with `metis reductionLoop_preserves_money_NoPayment`, and reversing the order in which the lemmas are defined.
> 
> **File `TimeRange.thy`, lemma `inIntervalIdempotentToIntersectInterval`, line *5***
> 
> The lemma can use a shorter proof: `apply (cases min2;cases max2;auto) done`.
> 
> **File `TimeRange.thy`, lemma `inIntervalIdempotency1, inIntervalIdempotency2`, lines *20, 36***
> 
> These lemmas use the `smt` tactic and `metis` where a simpler Isar proof would work, for example:
> 
> ``` text
>   lemma inIntervalIdempotency1 :
>     assumes "inInterval (x, y) (intersectInterval b c)"
>     shows "inInterval (x, y) b"
>   proof (cases b)
>     case [simp]:(Pair b1 b2)
>     thus ?thesis proof (cases c)
>       case (Pair c1 c2)
>       thus ?thesis using assms by (cases c1; cases c2; cases b1;cases b2; simp)
>     qed
>   qed
> ```
> 
> **File `SemanticsGuarantees.thy`, `Various lemmas/instantiations`**
> 
> Multiple lemmas and `linorder` instantiations in this file repeat auxiliary facts within the proof that are not necessary. For example, in the `linorder` instantiation for `Party`, lines 51--53 state
> 
> ``` {.text escapeinside="||" mathescape="true"}
>   have "(x < y) = (x |$\le$| y |$\land$| |$\neg$| y |$\le$| (x :: Token))"
>     by (meson less_Tok.simps less_Token_def less_eq_Token_def linearToken)
>   thus "(x < y) = (x |$\le$| y |$\land$| |$\neg$| y |$\le$| x)" by simp
> ```
> 
> This can be rewritten to avoid repeating the fact as
> 
> ``` {.text escapeinside="||" mathescape="true"}
>   show "(x < y) = (x |$\le$| y |$\land$| |$\neg$| y |$\le$| (x :: Token))"
>     by (meson less_Tok.simps less_Token_def less_eq_Token_def linearToken)
> ```
> 
> This pattern appears many times in this file. For example, in the `Party` instantation alone, it is present on lines 51 -- 53, 56 -- 57, 77 -- 80, and 83 -- 84.


### 2.3.23 Inconsistent style when applying constructor *(Severity: Low)*

> **File `SingleInputTransactions.thy`, lemmas `beforeApplyAllLoopIsUseless, fixIntervalOnlySummary`, lines *275, 398***
> 
> The lines mentioned in these lemmas display the resulting constructor before the function application, which differs from the general style in the rest of the codebase.


### 2.3.24 Unsimplified boolean formulas *(Severity: Low)*

> **File `SingleInputTransactions.thy`, lemma `computeTransactionIterative_aux2`, lines *708, 710***
> 
> In multiple places, this lemma formulation includes top-level negation in front of nontrivial conjunctions and disjunctions. These negations should be distributed. Otherwise, the reader is taxed with the chore to mentally distribute the negation to understand the lemma.


### 2.3.25 Typo with "independet" in multiple lemmas *(Severity: Low)*

> **File `SingleInputTransactions.thy`, lemmas `applyAllLoop_independet_of_acc_error1, applyAllLoop_independet_of_acc_error2`, lines *977, 987***
> 
> In both of these lemmas, there is a typo with the word "independet".


### 2.3.26 Poorly named `acc` lemmas *(Severity: Low)*

> **File `SingleInputTransactions.thy`, lemmas `applyAllLoop_independet_of_acc_error1, applyAllLoop_independet_of_acc_error2`, lines *977, 987***
> 
> It is unclear what `acc` refers to in these lemma names, as the lemmas are about the independence of warnings and payments, not accounts.


### 2.3.27 Verbose lemma statement `playTraceAuxIterative_base_case` *(Severity: Low)*

> **File `SingleInputTransactions.thy`, lemma `playTraceAuxIterative_base_case`, line *1063***
> 
> The statement of this lemma is very verbose. A more natural (and slightly stronger) formulation could be $$\begin{aligned} &\mathit{playTraceAux}\ \mathit{txOut}\ [\ \llparenthesis \mathit{interval} = \mathit{inte}, \mathit{inputs} = [h] \rrparenthesis, \llparenthesis \mathit{interval} = \mathit{inte}, \mathit{inputs} = t \rrparenthesis \ ] \\ =\ &\mathit{playTraceAux}\ \mathit{txOut}\ [\ \llparenthesis \mathit{interval} = \mathit{inte}, \mathit{inputs} = h\ \#\ t \rrparenthesis \ ]\end{aligned}$$


### 2.3.28 `playTrace_only_accepts_maxTransactionsInitialState` not written as `theorem` *(Severity: Low)*

> **File `TransactionBound.thy`, lemma `playTrace_only_accepts_maxTransactionsInitialState`, line *316***
> 
> This lemma seems like the main result of this file. Assuming it is an important result, we recommend writing it as a `theorem` rather than a `lemma`.


### 2.3.29 Inconsistent style with assumptions *(Severity: Low)*

> **File `Timeout.thy`, lemmas `timedOutReduceContractUntilQuiescent_closes_contract, timedOutReduceContractStep_empties_accounts`, lines *201/204, 211/214***
> 
> These lemmas use the hypothesis $\mathit{minTime}\ \mathit{sta} \leq \mathit{iniTime}$ and build a state $\mathit{sta}\ \llparenthesis \mathit{minTime} := \mathit{iniTime} \rrparenthesis)$ while other lemmas simply say $\mathit{minTime}\ \mathit{sta} = \mathit{iniTime}$. Readability would be improved by presenting these lemmas in the same style as the others, or documenting the need for these distinct presentations via code comments.


### 2.3.30 Function `validTimeInterval` unnecessarily unfolded in lemma *(Severity: Low)*

> **File `TimeRange.thy`, lemma `reduceStep_ifCaseLtCt_aux`, line *234***
> 
> For consistency, $a \leq b$ should be replaced by $\texttt{validTimeInterval}$.


### 2.3.31 Overly specific auxiliary lemma *(Severity: Low)*

> **File `ValidState.thy`, lemma `reductionLoop_preserves_valid_state_aux`, line *73***
> 
> This lemma on its own is very specific, and is only used in `reductionLoop_preserves_valid_state`. If possible, we recommend this lemma to be generalized or broken down into smaller lemmas, in order to present the arguments to the reader in smaller pieces.


### 2.3.32 `playTrace_preserves_valid_state` not written as `theorem` *(Severity: Low)*

> **File `ValidState.thy`, lemma `playTrace_preserves_valid_state`, line *194***
> 
> This lemma seems like the main result of this file. Assuming it is an important result, we recommend writing it as a `theorem` instead.


### 2.3.33 Unnecessary assumptions *(Severity: Low)*

> **File `PositiveAccounts.thy`, lemmas `addMoneyToAccountPositive_match, addMoneyToAccountPositive_noMatch`, lines *12, 23***
> 
> The assumptions $$\forall x\ \mathit{tok}.\ \mathit{positiveMoneyInAccountOrNoAccount}\ x\ \mathit{tok}\ \mathit{accs}$$ in `addMoneyToAccountPositive_match` and $$\mathit{money > 0}$$ in `addMoneyToAccountPositive_noMatch` are unnecessary.
> 
> **File `PositiveAccounts.thy`, lemma `reduceContractStep_gtZero_Refund`, line *93***
> 
> The lemma has an assumption that is mostly redundant.
> 
> ``` {.text escapeinside="||" mathescape="true"}
>   Reduced
>     ReduceNoWarning
>     (ReduceWithPayment (Payment party (Party party) tok2 money))
>     (state|$\llparenthesis$|accounts := newAccount|$\rrparenthesis$|) Close
>     =
>   Reduced wa eff newState newCont
> ```
> 
> A stronger lemma would be valid, which results from eliminating the assumption and changing the conclusion to `positiveMoneyInAccountOrNoAccount y tok3 newAccount`.
> 
> **File `QuiescentResult.thy`, lemma `reduceContractStepPayIsQuiescent`, line *17***
> 
> The assumption $\mathit{cont} = \texttt{Pay}\ \mathit{x21}\ \mathit{x22}\ \mathit{tok}\ \mathit{x23}\ \mathit{x24}$ is unnecessary.
> 
> **File `Timeout.thy`, lemma `timedOutReduce_only_quiescent_in_close_When`, line *43***
> 
> The assumption $\mathit{minTime}\ \mathit{sta} \leq \mathit{iniTime}$ is unnecessary.
> 
> **File `Timeout.thy`, lemma `timedOutReduce_only_quiescent_in_close`, line *122***
> 
> The assumption\ $\mathit{minTime}\ \mathit{sta} \leq \mathit{iniTime}$ is unnecessary. However, removing it will require the later proof `timedOutReduceContractLoop_closes_contract` to be adjusted.
> 
> **File `Timeout.thy`, lemma `timedOutReduceContractLoop_closes_contract`, lines *170, 173***
> 
> The assumptions $\mathit{minTime}\ \mathit{sta} \leq \mathit{iniTime}$ and $\mathit{minTime} \mathit{sta} = \mathit{iniTime}$ are both present. The former is redundant.
> 
> **File `TimeRange.thy`, lemma `reduceStep_ifCaseLtCt_aux`, line *234***
> 
> The assumption\ $\mathit{env} = \llparenthesis \mathit{timeInterval} = (a, b) \rrparenthesis$ is unnecessary.
> 
> **File `ValidState.thy`, lemma `reductionStep_preserves_valid_state_Refund`, line *29***
> 
> The assumption $$\begin{aligned} \mathit{newState} = \llparenthesis &\mathit{accounts} = \mathit{newAccounts}, \mathit{choices} = \mathit{newChoices}, \\ &\mathit{boundValues} = \mathit{newBoundValues}, \mathit{minTime} = \mathit{newMinTime} \rrparenthesis\end{aligned}$$ is unnecessary.


## 2.4 Isabelle implementation


### 2.4.1 Variable shadowing in `applyAllLoop` *(Severity: Medium)*

> **File `Semantics.thy`, function `applyAllLoop`, line *575***
> 
> The $\texttt{cont}$ variable introduced by the pattern match shadows another $\texttt{cont}$ variable, coming from the pattern match of an outer case expression, making the function harder to follow while also making it more error-prone to future changes.


### 2.4.2 Undescriptive name `moneyInPayment` *(Severity: Low)*

> **File `MoneyPreservation.thy`, function `moneyInPayment`, line *5***
> 
> The name of the function can be more precise. Perhaps `moneyInPaymentToParty` or `moneyInExternalPayment` would work.


### 2.4.3 Typo in section name *(Severity: Low)*

> **File `OptBoundTimeInterval.thy`, line `37`** 
> 
> Typo in section name: "Interval intesection".


### 2.4.4 Typo in comment *(Severity: Low)*

> **File `OptBoundTimeInterval.thy`, line `42`** 
> 
> Typo in comment: "endpoits".


### 2.4.5 Unclear need for multiple formulations for positive accounts *(Severity: Low)*

> **File `PositiveAccounts.thy`, `Throughout`** 
> 
> It is unclear what the use is for multiple formulations (and lemmas about) positive accounts. The first formulation (with the theorems `playTraceAux_gtZero` and `playTrace_gtZero`) is not used in any other modules but the alternative formulation is used instead. If both formulations are relevant, then it should be explained why.


### 2.4.6 Variable name discrepancy in `reductionLoop` *(Severity: Low)*

> **File `Semantics.thy`, function `reductionLoop`** 
> 
> When comparing this function against `specification-v3-rc1.pdf`, different names are used for a let-bound variable. It is `a` in the pdf and `newPayments` in the file `Semantics.thy`. There are similar issues in the function `reduceContractStep` in the equation for the `If` case, and in the function `giveMoney`.


### 2.4.7 Typo in constructor *(Severity: Low)*

> **File `Semantics.thy`, function `applyCases`, line *505***
> 
> Apparent typo in the error message constructor: the party mentioned should be $\texttt{party2}$.


### 2.4.8 Unclear function name `calculateNonAmbiguousInterval` *(Severity: Low)*

> **File `Semantics.thy`, function `calculateNonAmbiguousInterval`, line *725***
> 
> The meaning of the function is not obvious. It needs a comment to explain it.


### 2.4.9 Non-modularized file `SingleInputTransactions.thy` *(Severity: Low)*

> **File `SingleInputTransactions.thy`, `Splitting File`** 
> 
> This file is very long, and it covers more than just single-input transactions. For instance, about 530 lines at the beginning are rather dedicated to idempotence of certain operations. Then, the lemmas around lines 530 -- 700 focus on "well-foundedness" of the recursion on contract steps. Then there is also a clear block of lemmas about "distributivity" of semantics over transaction lists.
> 
> Splitting the module, grouping the related lemmas, would help understanding the relationships between the groups.


### 2.4.10 Misleading function names *(Severity: Low)*

> **File `SingleInputTransactions.thy`, function `inputsToTransactions`, line *9***
> 
> This function name is not very descriptive of its meaning. It takes a transaction (both a time interval and a list of inputs) and returns a list of transactions at the same interval containing a single input each. A name like `splitTransactionIntoSingleInputTransactions` would convey better what the input and the output are.
> 
> Moreover, the code would be cleaner if the function takes a single argument of type `Transaction`, instead of asking the caller to rip apart its fields.
> 
> **File `SingleInputTransactions.thy`, function `traceListToSingleInput`, line *18***
> 
> This function name is not descriptive of what it does. Perhaps a more telling name could be `splitTransactionsIntoSingleInputTransactions`.
> 
> **File `SingleInputTransactions.thy`, function `isSingleInput`, line *1222***
> 
> This function should be renamed or repurposed. If renamed, `allAreSingleInput` more accurately reflects the meaning of the function. If repurposed, it should check that a single transaction has a single input, and `all isSingleInput` can be used to express the current behavior.


### 2.4.11 Unused parameter in `maxTransactionCaseList` *(Severity: Low)*

> **File `TransactionBound.thy`, function `maxTransactionCaseList`, line *16***
> 
> This function has a parameter of type `State` that is completely unused and can be removed.


### 2.4.12 Duplicated `isValidInterval` function *(Severity: Low)*

> **File `TimeRange.thy`, function `isValidInterval`, line *231***
> 
> This function duplicates $\texttt{validTimeInterval}$ from $\texttt{OptBoundTimeInterval.thy}$, and the latter has certain additional properties proven about it specifically, so it makes sense to use the latter in both cases.


## 2.5 marlowe-cardano specification


### 2.5.1 Lack of guidelines for creating cooperating contracts *(Severity: Medium)*

> **File `marlowe-cardano-specification.md`, Section `Life Cycle of a Marlowe Contract`** 
> 
> Given that transactions are expected to work with Marlowe and non-Marlowe contracts simultaneously, it would be helpful to offer some guidelines for other contracts to avoid double satisfaction. Some degree of cooperation between the contracts that can appear in the same transaction is unavoidable.
> 
> One measure could be to ask every cooperating contract to refrain from paying to the payout validator. In this way, double satisfaction can not affect the payments of the Marlowe contract, if the Marlowe contract only pays to roles rather than addresses.
> 
> Another alternative would be to demand other contracts' outputs to use datums that are different from the roles used by the Marlowe contract for payments.

TODO: @bwbush will add text here.

```console
commit 00010ea48439892ff9eec54fb93929f56bcb6c7b
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 11:20:14 2023 -0700

    PLT-4169 Added text on running Plutus with Marlowe to specification doc.
    
    This addresses the following audit comment:
    
    > File marlowe-cardano-specification.md, Section Life Cycle of a
    > Marlowe Contract Given that transactions are expected to work
    > with Marlowe and non-Marlowe contracts simultaneously, it would
    > be helpful to offer some guidelines for other contracts to avoid
    > double satisfaction. Some degree of cooperation between the
    > contracts that can appear in the same transaction is unavoidable.
    >
    > One measure could be to ask every cooperating contract to refrain
    > from paying to the payout validator. In this way, double satisfaction
    > can not affect the payments of the Marlowe contract. Another
    > alternative would be to demand other contracts’ outputs to use datums
    > that are different from the roles used by the Marlowe contract for
    > payments.
```


### 2.5.2 No reference to creating a minting policy *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, Section `Monetary Policy for Role Tokens`** 
> 
> The minting policy is not specified, but a reference needs to be offered to explain how to create one.

TODO: @bwbush will add text here.

```console
commit fe00af7d622bbd17c3327363d4650ee544d1fff7
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 11:25:09 2023 -0700

    PLT-4169 Added text to specification on how to mint role tokens.
    
    This addresses the audit comment:
    
    > File marlowe-cardano-specification.md, Section Monetary Policy
    > for Role Tokens The minting policy is not specified, but a
    > reference needs to be offered to explain how to create one.
```


### 2.5.3 Argument for Contract in `txInfoData` not specified *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, Section `Types`** 
> 
> The argument by which the `Contract` in the `txInfoData` list corresponds to the given hash needs to be made explicit.

TODO: @bwbush will add text here.

```console
commit b6366efc9f8df38bfe9232f81e6caf2c7f11ffa8
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 11:31:11 2023 -0700

    PLT-4169 Made explicit the relationship between continuation and its hash.
    
    This addresses the audit comment:
    
    > File marlowe-cardano-specification.md, Section Types The argument
    > by which the Contract in the txInfoData list corresponds to the
    > given hash needs to be made explicit.
```


### 2.5.4 Merkleization section not detailed enough *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, Section `Merkleization`**
> 
> This section is too terse. It needs to explain what Merkleization is, and to motivate why it is needed.
> 
> When explaining how it works, it needs to make explicit that only the `Case` type is modified, and that in the semantics, only the `Input` type is modified. It needs to explain why the `Input` type needs to carry a hash and a contract, and why the evaluation of the contract is changed as described.

TODO: @bwbush will add text here.

```console
commit a9d4043230cb4f240fab2d816bed6a3cab4f5053
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 11:44:32 2023 -0700

    PLT-4169 Elaborated explanation of and motivation for merkleization.
    
    This addresses the audit comment:
    
    > File marlowe-cardano-specification.md, Section Merkleization
    > This section is too terse. It needs to explain what Merkleization
    > is, and to motivate why it is needed. When explaining how it works,
    > it needs to make explicit that only the Case type is modified, and
    > that in the semantics, only the Input type is modified. It needs
    > to explain why the Input type needs to carry a hash and a contract,
    > and why the evaluation of the contract is changed as described.
```


### 2.5.5 Unnecessary constraint *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, `Constraint 12. Merkleized continuations`** 
> 
> This constraint is unnecessary to have in the Marlowe validator, since the construction of the arguments for evaluation of the Marlowe contract would fail. However, it would be useful to have it appear in the specification for users to be aware of it when crafting transactions. A note to motivate the presence of the constraint could be helpful.

TODO: @bwbush will add text here.

```console
commit fda1d3e862fc8f8c31ff479fbd338226e661eb0b
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 11:50:20 2023 -0700

    PLT-4169 Clarified nature of Constraint 12 in specification.
    
    This addresses the auditor comment:
    
    > File marlowe-cardano-specification.md, Constraint 12. Merkleized
    > continuations This constraint is unnecessary to have in the
    > Marlowe validator, since the construction of the arguments for
    > evaluation of the Marlowe contract would fail. However, it would
    > be useful to have it appear in the specification, for users to
    > be made aware of it when crafting transactions. A note to motivate
    > the presence of the constraint could be helpful.
```


### 2.5.6 Asymmetry between role and wallet payouts *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, `Constraint 15`, **
> 
> The marlowe validator allows multiple outputs to be paid to a wallet, but it demands that a single output exists when paying to a role instead. The motivation to use different approaches needs to be documented. This is implemented in `Scripts.hs` at line 371, in function `payoutConstraints`.

TODO: @bwbush will add text here.

```console
commit 4e81470de90ddd6858c3ad8aace96e90df5a86ae
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Wed Mar 1 17:40:38 2023 -0700

    SCP-5128 Commented on rationale for allowing multiple outputs to an address.
```

### 2.5.7 Incorrect description of `rolePayoutValidator` *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, Section `Plutus Validator for Marlowe Payouts`** 
> 
> The description of the Marlowe payout validator in the specification states that it is parameterized by the currency symbol. However, this is not correct as the validator is unparameterized; rather, the datum type of the validator includes the currency symbol (as well as token name). The description should be modified to reflect this.

TODO: @bwbush will add text here.

```console
commit 1d16de1f1b7a167dc4eb4a057a3df2c24d0194c9
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 11:12:36 2023 -0700

    PLT-4169 Fixed example call to `rolePayoutValidator`.
    
    This addresses the following audit finding:
    
    > File marlowe-cardano-specification.md, Section Plutus Validator
    > for Marlowe Payouts The type signature of rolePayoutValidator
    > is missing the datum argument. It should be: rolePayoutValidator
    > :: CurrencySymbol -> TokenName -> () -> ScriptContext -> Bool
```


### 2.5.8 Unspecified initial state *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, Section `Life Cycle of a Marlowe Contract`** 
> 
> The specification should say what the initial state of a Marlowe contract should be. In particular, creating a contract requires giving the minimum Ada to some account in the Marlowe state. Otherwise, Constraint 5 will reject the transactions that try to spend the output.

TODO: @bwbush will add text here.

```console
commit e150e30867dfa5466639f46bf39656aee2888e38
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 12:34:38 2023 -0700

    PLT-4169 Elaborated in specification on the required initial state.
    
    This addresses the audit comment:
    
    > File marlowe-cardano-specification.md, Section Life Cycle of a
    > Marlowe Contract The specification should say what the initial
    > state of a Marlowe contract should be. In particular, creating
    > a contract requires giving the minimum Ada to some account in
    > the Marlowe state. Otherwise, Constraint 5 will reject the
    > transactions that try to spend the output.
```


### 2.5.9 Unspecified behavior when multiple cases can apply *(Severity: Low)*

> **File `Semantics.hs`, Function `applyCases`, line *597***
> 
> If multiple cases in a case list can apply, the first one is taken. This behavior should be better communicated in the specification.

TODO: @bwbush will add text here.

```console
commit 08d6f34ac91da7aa34e7414c5bae0e33e9235d74
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 12:06:10 2023 -0700

    PLT-4169 Improved documentation of `applyCases`.
    
    This addresses the audit comment:
    
    > File Semantics.hs, Function applyCases, line 597 If multiple
    > cases in a case list can apply, the first one is taken. This
    > behavior should be better communicated in the specification.
```

## 2.6 Haskell implementation


### 2.6.1 Name shadowing in `applyAllInputs` *(Severity: Medium)*

> **File `Semantics.hs`, Function `applyAllInputs`, line *658***
> 
> The binding `cont` from the `Applied` constructor shadows the `cont` variable coming from the pattern match in an enclosing case expression. This makes the code error-prone to subsequent changes and refactorings.

TODO: @bwbush will add text here.

```console
```

### 2.6.2 Non-isomorphic types in `playTraceAux` *(Severity: Medium)*

> **File `Semantics.hs`, Function `playTraceAux`, line *710***
> 
> The function in the Isabelle code takes a `TransactionOutputRecord` while the Haskell version takes a `TransactionOutput`. This means `TransactionError` cannot be an input to `playTraceAux` in Isabelle, possibly invalidating proofs about its properties.

TODO: @bwbush will add text here.

```console
```


### 2.6.3 Variable names differ from Isabelle code *(Severity: Low)*

> **File `Semantics.hs`, Several functions ``** 
> 
> Different variable names in Isabelle and Haskell make comparison harder. It is less of an issue when only one variable has been renamed in a function, but multiple variable renames require carefully mapping between the names to avoid confusion. For example, the code of `reduceContractStep` in line 482 (`Pay` case) is hard to compare.
> 
> Other name changes include:
> -   Line 456, function `updateMoneyInAccount` uses variable `money` where the Isabelle code uses `amount` and omits naming the last parameter.
> -   Line 473, function `giveMoneyToPay` uses variables `amount` and `accounts` instead of `money` and `accountsV` as in the Isabelle code.
> -   Line 541, function `reductionLoop` uses variable `con` instead of `ncontract`.
> -   Line 300, the data type `TransactionInput` corresponds to the type `Transaction` in the Isabelle code.
> -   Line 313, the data type `TransactionOutput` is isomorphic but not identical to the homonymous data type in the Isabelle code.
> -   Line 439, function `refundOne` uses a variable `balance` where the Isabelle code uses `money`.
> -   Line 463, function `addMoneyToAccount` uses variable `accounts` where the Isabelle code uses `accountsV`.

TODO: @bwbush will add text here.

```console
commit 1c96edfe7e22ecc499ed75dd175490a4f2427bdc
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 13:24:06 2023 -0700

    PLT-4169 Renamed functions, per audit recommendations.
```


### 2.6.4 Naming of functions and variables *(Severity: Low)*

> **File `Several files`, `several functions`** 
> 
> Several functions or variables could have more descriptive or precise names, for example:
> -   `Scripts.hs:193`: `validateBalances` could be called `allBalancesArePositive`.
> -   `Scripts.hs:206`: `validateInputs` could be called `allInputsAreAuthorized`.
> -   `Scripts.hs:324`: `checkScriptOutputAny` could be called `noOutputPaysToOwnAddress`, as it checks that *no* outputs pay to the script address.
> -   `Semantics.hs:439`: `refundOne` is named somewhat confusingly, and understanding the name requires the context of `reduceContractStep` where the function is called. Perhaps a better name would be `dropWhileNonPositiveAndUncons`.
> -   `Semantics.hs:597`: the binding `tailCase` should rather be named `tailCases`.


TODO: @bwbush will add text here.

```console
commit 1c96edfe7e22ecc499ed75dd175490a4f2427bdc
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 13:24:06 2023 -0700

    PLT-4169 Renamed functions, per audit recommendations.
```

### 2.6.5 Unused functions *(Severity: Low)*

> **File `Several files`, `several functions`** 
> 
> Several functions are unused and perhaps should be removed:
> -   `Semantics.hs:741`: `contractLifespanUpperBound` does not seem to be used anywhere, including tests.
> -   `Semantics.hs:680`: `isClose` is not used in the rest of the codebase (besides checking its behavior via testing). It should either be removed, or comments justifying its existence should be included.
> 
> In addition to that, the functions `validateBalances` and `totalBalance` (defined at `Semantics.hs:755` and `:762`) are only used in `Scripts.hs` and never reused, so they should probably be moved to `Scripts.hs`.

TODO: @bwbush will add text here.

```console
```


### 2.6.6 Comments *(Severity: Low)*

> **File `Semantics.hs`, Function `refundOne`, line *439***
> 
> The comment describing the function is overly concise, as it does not mention the function removing all non-positive accounts before the first positive one, and effectively `uncons`-ing the list.
> 
> **File `Semantics.hs`, Function `addMoneyToAccount`, line *461***
> 
> There is a typo in the comment: `accoun` is written instead of `account`.

TODO: @bwbush will add text here.

```console
```


### 2.6.7 Record updates in `playTraceAux` *(Severity: Low)*

> **File `Semantics.hs`, Function `playTraceAux`, line *710***
> 
> The function could have followed the Isabelle code more closely if it used a record update instead of creating a new `TransactionOutput` record from scratch.

TODO: @bwbush will add text here.

```console
```


### 2.6.8 Potential simplifications *(Severity: Low)*

> **File `Semantics.hs`, Function `totalBalance`, line *755***
> 
> The function uses `foldMap f . AssocMap.toList`. Here, `AssocMap.toList` is redundant.

> **File `Types.hs`, Class instance `Eq Contract`, line *873***
> 
> The equality of cases for the `When` constructor would be simplified by using `cases1 == cases2`. If there is a reason for the more verbose equality condition, it should be outlined in a comment.

TODO: @bwbush will add text here.

```console
```


### 2.6.9 `computeTransaction` differs from the Isabelle implementation *(Severity: Low)*

> **Helper function `evalValue, evalObservation`, lines *391 (Semantics.hs), 34 (Semantics.thy)***
> 
> `evalValue` and `evalObservation` differ from the Isabelle implementation in the introduction of auxiliary variables to abbreviate the recursive calls. The comparison would be simpler if both definitions were consolidated.
 
> **Helper function `evalValue`, lines *395 (Semantics.hs), 35 (Semantics.thy)***
> 
> The Isabelle implementation should use the helper function `moneyInAccount` instead of inlining its definition, so as to maintain consistency with the Haskell implementation.
 
> **Helper function `applyCases`, lines *596 (Semantics.hs), 498 (Semantics.thy)***
> 
> The structure of function `applyCases` differs between the Haskell and Isabelle files. Specifically, the Haskell implementation has an additional function `applyAction` where the Isabelle implementation does not. A comment motivating the discrepancy would be needed. This is likely due to the lack of Merkleization in the Isabelle implementation.

TODO: @bwbush will add text here.

```console
commit d0a3834ae8484bb6c7d0ecd3aeec60871b3fd165
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 13:00:28 2023 -0700

    PLT-4169 Added comment about merkleization to `applyCases`.
    
    This addresses the audit comment:
    
    > Helper function applyCases, lines 596 (Semantics.hs), 498
    > (Semantics.thy) The structure of function applyCases differs
    > between the Haskell and Isabelle files. Specifically, the
    > Haskell implementation has an additional function applyAction
    > where the Isabelle implementation does not. A comment
    > motivating the discrepancy would be needed. This is likely
    > due to the lack of Merkleization in the Isabelle implementation.
```
 
> **Helper function `convertReduceWarnings`, lines *617 (Semantics.hs), 537 (Semantics.thy)***
> 
> The Haskell function is implemented using `foldr`, while the Isabelle function uses explicit recursion, making a one-to-one comparison less obvious. If there is a reason for this discrepancy, such as `foldr` yielding some optimizations, this should be outlined in a comment.

TODO: @bwbush will add text here.

```console
commit d14776101c22eac7fbc67893020f37cbc2a9e339
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 13:02:40 2023 -0700

    PLT-4169 Added note on use of `foldr` in semantics.
    
    This addresses the audit comment:
    
    > Helper function convertReduceWarnings, lines 617 (Semantics.hs),
    > 537 (Semantics.thy) The Haskell function is implemented using
    > foldr, while the Isabelle function uses explicit recursion,
    > making a oneto-one comparison less obvious. If there is a
    > reason for this discrepancy, such as foldr yielding some
    > optimizations, this should be outlined in a comment.
```

### 2.6.10 Constraint implementations differ from description *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, Section `Plutus Validator for Marlowe Semantics`** 
> 
> Some constraints mentioned in the specification are written in a different structure than the corresponding constraint in `Scripts.hs`. While such a discrepancy may be useful to minimize verbosity, a unified structure when possible would alleviate a side-by-side comparison. Examples of these differing structures include Constraint 6 and Constraint 14.

TODO: @bwbush will add text here.

```console
```


### 2.6.11 Missing argument of `computeTransaction` *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, Section `Relationship between Marlowe Validator and Semantics`** 
> 
> The specification mentions the output datum as the (fifth) argument for the `computeTransaction` function, while it is not an argument to it.

TODO: @bwbush will add text here.

```console
commit 00a0c2406665f06753aecf6dbb63933edb275436
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 12:39:22 2023 -0700

    PLT-4169 Fixed correspondence between semantics and validator.
    
    This addresses the audit comment:
    
    > File marlowe-cardano-specification.md, Section Relationship
    > between Marlowe Validator and Semantics The specification
    > mentions the output datum as the (fifth) argument for the
    > computeTransaction function, while it is not an argument to it.
```

### 2.6.12 Missing `smallMarloweValidator` *(Severity: Low)*

> **File `marlowe-cardano-specification.md`, Various sections ``** 
> 
> The specification mentions `smallMarloweValidator` in a few places, but it is never mentioned in the source code.

TODO: @bwbush will add text here.

```console
commit 87cf548d9ae7934a702ea1a1c85d7d9bd4993aa9
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 12:37:21 2023 -0700

    PLT-4169 Fixed references to `smallMarloweValidator`.
    
    This addresses the audit comment:
    
    > File marlowe-cardano-specification.md, Various sections
    > The specification mentions smallMarloweValidator in a few
    > places, but it is never mentioned in the source code.
```


### 2.6.13 Incorrect constraint reference *(Severity: Low)*

> **File `Scripts.hs`, Function `mkRolePayoutValidator`, line *150***
> 
> This line should refer to Constraint 17 rather than Constraint 16.

TODO: @bwbush will add text here.

```console
commit 3fac0d1749d107f13743756aa50c9723e776e391
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 12:42:01 2023 -0700

    PLT-4169 Fixed incorrect constraint reference.
    
    This addresses the audit comment:
    
    > File Scripts.hs, Function mkRolePayoutValidator, line 150 This line should refer to Constraint 17
    rather than Constraint 16.
```


### 2.6.14 `MarloweParams` differs from the specification *(Severity: Low)*

> **File `Semantics.hs`, type `MarloweParams`, line *355***
> 
> The specification defines `MarloweParams` to contain just the payout validator hash, while the definition in the Haskell code contains just the roles currency symbol.

TODO: @bwbush will add text here.

```console
commit 8691f3351e55758cc750eee0800b1458f0a8c554
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 12:44:53 2023 -0700

    PLT-4169 Fixed `MarloweParams` in specification.
    
    This addresses the audit comment:
    
    > File Semantics.hs, type MarloweParams, line 355 The specification
    > defines MarloweParams to contain just the payout validator hash,
    > while the definition in the Haskell code contains just the roles
    > currency symbol.
```

### 2.6.15 Timeout boundary differs from the specification *(Severity: Low)*

> **File `Semantics.hs`, type `reduceContractStep`, line *518***
> 
> The specification mentions
> 
> > If a valid Transaction is computed with a TimeInterval with a start time bigger than the Timeout t, the contingency continuation c is evaluated.
> 
> where "bigger" implies strict inequality, while the code makes non-strict comparison. This difference needs to be acknowledged and further explained in the specification.

TODO: @bwbush will add text here.

```console
```

## 2.7 Haskell tests


### 2.7.1 More precise failure checks *(Severity: Medium)*

> **File `Spec/Marlowe/Plutus/Specification.hs`, `Various tests`** 
> 
> The tests use the functions `checkSemanticsTransaction` and `checkPayoutTransaction` to verify that various error conditions cause transactions to be rejected. These functions test that a transaction passes or fails, but when it fails, the functions do not consider the error cause. Checking the exact cause is necessary to ensure the transaction is rejected because of the intended reason and not because of some other error condition arising in a particular test case by coincidence.
> 
> The absence of this information makes it easier to accidentally produce a test that is not testing what is intended.

TODO: @bwbush will add text here.

```console
```

### 2.7.2 Missing tests *(Severity: Medium)*

> **File `Spec/Marlowe/Semantics/Compute.hs`, ``** 
> 
> The following properties could additionally be tested for `computeTransaction`:
> -   payment subtracts from an account,
> -   deposit adds to an account,
> -   `INotify` input produces the expected continuation,
> -   `IChoice` input produces the expected continuation,
> -   the hash of a successfully applied merkleized input matches the hash of the merkleized case.
> 
> Some of these are tested in `Spec/Marlowe/Semantics/Functions.hs` already for auxiliary functions.

TODO: @bwbush will add text here.

```console
commit ee2e52220e25736af29a1f01144d5fafbe9eed76
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 07:36:59 2023 -0700

    PLT-4168 Tests that choice and deposit continue as expected.

commit 333eee293aa3afe95d0aa7f678c7e7b7bad660ea
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 07:18:27 2023 -0700

    PLT-4168 Test that choice produces expected continuation.

commit 477284c78095482eba63adc2e6090ea68553db9d
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 06:54:14 2023 -0700

    PLT-4168 Tested that deposits add to account.

commit d241669bfb7ec8dad1cc92a7ca6185d08229817e
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Mon Mar 6 14:38:09 2023 -0700

    PLT-4168 Tested that payout substracts from account.

commit f33fc7206522031c93253323f3b8ca083d8ca8c7
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Tue Mar 7 09:56:30 2023 -0700

    PLT-4168 Tested that Merkleization continues as expected.
```
 
> **File `Spec/Marlowe/Semantics/Functions.hs`, `Missing merkleization tests`** 
> 
> The properties in this module do not seem to be tested with merkleized contracts or inputs except for `checkGetContinuation`. More merkleization tests should be added.

TODO: @bwbush will add text here.

```console
commit 2a936bf1bbb890cc811b966b46a10fd38314dc25
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Mon Mar 6 11:40:56 2023 -0700

    PLT-4168 Increased coverage of merkleization in validator tests.
    
    This addresses the following audit finding:
    
    > File Spec/Marlowe/Semantics/Functions.hs, Missing
    > merkleization tests The properties in this module
    > do not seem to be tested with merkleized contracts
    > or inputs except for checkGetContinuation, and
    > they probably should.

commit 8f8183d7f14c6bdc3841a1999077ef01ebac4144
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Mon Mar 6 11:40:56 2023 -0700

    PLT-4168 Increased coverage of merkleization in validator tests.
    
    This addresses the following audit finding:
    
    > File Spec/Marlowe/Semantics/Functions.hs, Missing
    > merkleization tests The properties in this module
    > do not seem to be tested with merkleized contracts
    > or inputs except for checkGetContinuation, and
    > they probably should.
```
 
> **File `Spec/Marlowe/Semantics/Compute.hs`, function `checkFixInterval`, lines *100-102***
> 
> The test `checkFixInterval` is never instantiated with an invalid interval that is in the past, meaning the function `fixInterval` is never tested for that case.

TODO: @bwbush will add text here.

```console
commit 811f048ba93db10972641c0c235864db1d6014e7
Author: Brian W Bush <brian.bush@iohk.io>
Date:   Mon Mar 6 10:16:08 2023 -0700

    PLT-4168 Added test for invalid interval in past.
    
    This addresses the following audit finding:
    
    > File Spec/Marlowe/Semantics/Compute.hs, function checkFixInterval,
    > lines 100-102 The test checkFixInterval is never instantiated
    > with an invalid interval that is in the past, meaning the function
    > fixInterval is never tested for that case.
```

